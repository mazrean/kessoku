# Kessoku

[![Go Reference](https://pkg.go.dev/badge/github.com/mazrean/kessoku.svg)](https://pkg.go.dev/github.com/mazrean/kessoku)

A dependency injection code generator for Go, similar to [google/wire](https://github.com/google/wire). Kessoku generates Go code for compile-time dependency injection, eliminating runtime reflection overhead.

## Features

**üöÄ Parallel Processing** - Execute independent providers concurrently with `kessoku.Async()` while maintaining dependency order and automatic context injection
**‚ö° Compile-time Optimization** - Zero runtime overhead with static code generation, full type safety, and optimal performance
**üîß Enhanced Developer Experience** - Automatic error handling, cycle detection, and seamless Go generate integration

## üöÄ Performance Comparison

| Approach | Execution Time | Performance |
|----------|---------------|-------------|
| **Sequential** (google/wire style) | `200ms + 150ms + 100ms = 450ms` | ‚è±Ô∏è Slow |
| **Parallel** (Kessoku) | `max(200ms, 150ms, 100ms) = 200ms` | ‚ö° **2.25x Faster** |

<details>
<summary>üìã Show Code Examples</summary>

**Sequential Approach (google/wire style)**
```go
// Sequential execution - each provider waits for the previous one
func InitializeApp() (*App, error) {
    config := NewConfig()                    // 0ms
    db, err := NewDatabaseService(config)    // 200ms (waits)
    if err != nil {
        return nil, err
    }
    cache := NewCacheService(config)         // 150ms (waits)
    messaging := NewMessagingService()       // 100ms (waits)
    return NewApp(db, cache, messaging), nil // Total: 450ms
}
```

**Parallel Approach (Kessoku)**
```go
// Kessoku declaration - providers run in parallel
var _ = kessoku.Inject[*App](
    "InitializeApp",
    kessoku.Provide(NewConfig),                          // 0ms
    kessoku.Async(kessoku.Provide(NewDatabaseService)),  // 200ms (parallel)
    kessoku.Async(kessoku.Provide(NewCacheService)),     // 150ms (parallel)
    kessoku.Async(kessoku.Provide(NewMessagingService)), // 100ms (parallel)
    kessoku.Provide(NewApp),                             // Waits for all
)
// Generated code executes in parallel - Total: 200ms
```

</details>

### Real-world Impact
- **Application Startup**: 450ms ‚Üí 200ms (**55% faster**)
- **Test Suite**: Faster dependency setup means faster tests
- **Development**: Quick feedback loop during development

## Installation

**Recommended: Go Tool**

```bash
go get -tool github.com/mazrean/kessoku/cmd/kessoku@latest
```

This installs kessoku as a Go tool, making it available via `go tool kessoku`.

**Other Methods**
<details>
<summary>Go Install</summary>

```bash
go install github.com/mazrean/kessoku/cmd/kessoku@latest
```
</details>

<details>
<summary>Download binary</summary>

Download the latest binary from the [releases page](https://github.com/mazrean/kessoku/releases).
</details>

<details>
<summary>Homebrew</summary>

```bash
brew install mazrean/tap/kessoku
```
</details>

## Quick Start

Experience Kessoku's **parallel processing power** in 3 simple steps:

### 1. Define Your Services with Async Providers

```go
//go:generate go tool kessoku $GOFILE

package main

import (
    "time"
    "github.com/mazrean/kessoku"
)

// Slow services that can run in parallel
func NewDatabaseService() (*DatabaseService, error) {
    time.Sleep(200 * time.Millisecond) // Simulate slow DB connection
    return &DatabaseService{}, nil
}

func NewCacheService() *CacheService {
    time.Sleep(150 * time.Millisecond) // Simulate slow cache connection
    return &CacheService{}
}

func NewMessagingService() *MessagingService {
    time.Sleep(100 * time.Millisecond) // Simulate slow messaging setup
    return &MessagingService{}
}

// Declare parallel execution with kessoku.Async()
var _ = kessoku.Inject[*App](
    "InitializeApp",
    kessoku.Async(kessoku.Provide(NewDatabaseService)),   // 200ms
    kessoku.Async(kessoku.Provide(NewCacheService)),      // 150ms  
    kessoku.Async(kessoku.Provide(NewMessagingService)),  // 100ms
    kessoku.Provide(NewApp),                              // Waits for all
)
```

### 2. Generate and Get Dramatic Performance Boost

```bash
go generate ./...
```

<details>
<summary>üîß Show Generated Code</summary>

```go
// Code generated by kessoku. DO NOT EDIT.

package main

import (
    "context"
    "github.com/mazrean/kessoku"
    "golang.org/x/sync/errgroup"
)

func InitializeApp(ctx context.Context) (*App, error) {
    var (
        databaseService    *DatabaseService
        cacheService       *CacheService
        cacheServiceCh     = make(chan struct{})
        messagingService   *MessagingService
        messagingServiceCh = make(chan struct{})
        app                *App
    )
    
    eg, ctx := errgroup.WithContext(ctx)
    
    // Async provider: NewDatabaseService
    eg.Go(func() error {
        var err error
        databaseService, err = kessoku.Async(kessoku.Provide(NewDatabaseService)).Fn()()
        if err != nil {
            return err
        }
        // Wait for dependencies and create App
        select {
        case <-cacheServiceCh:
        case <-ctx.Done():
            return ctx.Err()
        }
        select {
        case <-messagingServiceCh:
        case <-ctx.Done():
            return ctx.Err()
        }
        app = kessoku.Provide(NewApp).Fn()(databaseService, cacheService, messagingService)
        return nil
    })
    
    // Async provider: NewMessagingService
    eg.Go(func() error {
        messagingService = kessoku.Async(kessoku.Provide(NewMessagingService)).Fn()()
        close(messagingServiceCh)
        return nil
    })
    
    cacheService = kessoku.Async(kessoku.Provide(NewCacheService)).Fn()()
    close(cacheServiceCh)
    
    if err := eg.Wait(); err != nil {
        return nil, err
    }
    
    return app, nil
}
```

</details>

Kessoku generates **optimized parallel code** with automatic context injection and synchronization, delivering **2.25x faster execution** compared to sequential approaches.

### 3. Use the Generated Injector

```go
package main

import (
    "context"
    "fmt"
    "log"
    "time"
)

func main() {
    start := time.Now()
    
    // Generated injector with context support
    app, err := InitializeApp(context.Background())
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("App initialized in %v\n", time.Since(start))
    // Output: App initialized in ~200ms (instead of 450ms!)
}
```

## CLI Usage

```
Usage: kessoku <files> ... [flags]

A dependency injection code generator for Go, similar to google/wire

Arguments:
  <files> ...    Go files to process

Flags:
  -h, --help                Show context-sensitive help.
  -l, --log-level="info"    Log level
  -v, --version             Show version and exit.
```

**Common usage**
```bash
go tool kessoku kessoku.go        # Process single file
go tool kessoku *.go              # Process multiple files
go generate ./...                 # Using go generate (recommended)
```

## API Reference

For detailed API documentation, see the [Go Reference](https://pkg.go.dev/github.com/mazrean/kessoku).

### Quick Reference

- **`kessoku.Inject[T](name, ...providers)`** - Declares an injector function
- **`kessoku.Provide(fn)`** - Wraps a provider function for dependency injection
- **`kessoku.Async(provider)`** - Enables parallel execution of independent providers
- **`kessoku.Bind[I](provider)`** - Binds an interface to its implementation
- **`kessoku.Value(val)`** - Provides a constant value
- **`kessoku.Set(...providers)`** - Groups related providers together as a reusable set

## Examples

See the [examples/](./examples/) directory for complete working examples:

- **[basic/](./examples/basic/)** - Simple synchronous dependency injection
- **[async_parallel/](./examples/async_parallel/)** - Parallel execution of independent async providers
- **[complex_async/](./examples/complex_async/)** - Complex async dependency chains with coordination
- **[sets/](./examples/sets/)** - Using value sets for configuration
- **[cross_package/](./examples/cross_package/)** - Cross-package dependency injection

## Development

For development guidelines, building, testing, and contributing instructions, see [DEVELOPMENT.md](./DEVELOPMENT.md).

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request
