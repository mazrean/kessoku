package kessoku

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"io"

	"golang.org/x/tools/imports"
)

func Generate(w io.Writer, filename string, metaData *MetaData, injectors []*Injector) error {
	astFile := &ast.File{
		Name: &ast.Ident{
			Name: metaData.Package,
		},
		Imports: metaData.Imports,
		Decls:   make([]ast.Decl, 0, len(injectors)+1),
	}

	importDecl := generateImportDecl(metaData.Imports)
	if importDecl != nil {
		astFile.Decls = append(astFile.Decls, importDecl)
	}

	for _, injector := range injectors {
		astFile.Decls = append(astFile.Decls, generateInjectorDecl(injector))
	}

	buf := bytes.NewBuffer(nil)

	err := format.Node(buf, token.NewFileSet(), astFile)
	if err != nil {
		return fmt.Errorf("format node: %w", err)
	}

	codeBytes, err := imports.Process(filename, buf.Bytes(), nil)
	if err != nil {
		return fmt.Errorf("process imports: %w", err)
	}

	_, err = w.Write([]byte("// Code generated by kessoku. DO NOT EDIT.\n\n"))
	if err != nil {
		return fmt.Errorf("write code: %w", err)
	}

	_, err = w.Write(codeBytes)
	if err != nil {
		return fmt.Errorf("write code: %w", err)
	}

	return nil
}

func generateImportDecl(imporSpecs []*ast.ImportSpec) *ast.GenDecl {
	specs := make([]ast.Spec, 0, len(imporSpecs))
	for _, importSpec := range imporSpecs {
		specs = append(specs, importSpec)
	}
	if len(specs) == 0 {
		return nil
	}

	return &ast.GenDecl{
		Tok:   token.IMPORT,
		Specs: specs,
	}
}

func generateInjectorDecl(injector *Injector) ast.Decl {
	paramFields := make([]*ast.Field, 0, len(injector.Args))
	for _, arg := range injector.Args {
		paramFields = append(paramFields, &ast.Field{
			Names: []*ast.Ident{ast.NewIdent(arg.Param.Name())},
			Type:  arg.Arg.ASTTypeExpr,
		})
	}

	resultFields := make([]*ast.Field, 0, 2)
	resultFields = append(resultFields, &ast.Field{
		Type: injector.Return.Return.ASTTypeExpr,
	})
	if injector.IsReturnError {
		resultFields = append(resultFields, &ast.Field{
			Type: ast.NewIdent("error"),
		})
	}

	var stmts []ast.Stmt
	for _, stmt := range injector.Stmts {
		lhs := make([]ast.Expr, 0, len(stmt.Returns)+1)
		for _, ret := range stmt.Returns {
			lhs = append(lhs, &ast.Ident{
				Name: ret.Name(),
			})
		}
		if stmt.Provider.IsReturnError {
			lhs = append(lhs, &ast.Ident{
				Name: "err",
			})
		}

		args := make([]ast.Expr, 0, len(stmt.Arguments))
		for _, arg := range stmt.Arguments {
			args = append(args, ast.NewIdent(arg.Name()))
		}

		rhs := &ast.CallExpr{
			Fun: &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   stmt.Provider.ASTExpr,
					Sel: ast.NewIdent("Fn"),
				},
				Args: []ast.Expr{},
			},
			Args: args,
		}

		stmts = append(stmts, &ast.AssignStmt{
			Tok: token.DEFINE,
			Lhs: lhs,
			Rhs: []ast.Expr{rhs},
		})

		if stmt.Provider.IsReturnError {
			stmts = append(stmts, &ast.IfStmt{
				Cond: &ast.BinaryExpr{
					X:  ast.NewIdent("err"),
					Op: token.NEQ,
					Y:  ast.NewIdent("nil"),
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.DeclStmt{
							Decl: &ast.GenDecl{
								Tok: token.VAR,
								Specs: []ast.Spec{
									&ast.ValueSpec{
										Names: []*ast.Ident{ast.NewIdent("zero")},
										Type:  injector.Return.Return.ASTTypeExpr,
									},
								},
							},
						},
						&ast.ReturnStmt{
							Results: []ast.Expr{
								ast.NewIdent("zero"),
								ast.NewIdent("err"),
							},
						},
					},
				},
			})
		}
	}

	returns := make([]ast.Expr, 0, 2)
	returns = append(returns, ast.NewIdent(injector.Return.Param.Name()))
	if injector.IsReturnError {
		returns = append(returns, ast.NewIdent("nil"))
	}

	stmts = append(stmts, &ast.ReturnStmt{
		Results: returns,
	})

	funcDecl := &ast.FuncDecl{
		Name: ast.NewIdent(injector.Name),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: paramFields,
			},
			Results: &ast.FieldList{
				List: resultFields,
			},
		},
		Body: &ast.BlockStmt{
			List: stmts,
		},
	}

	return funcDecl
}
