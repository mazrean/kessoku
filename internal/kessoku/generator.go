package kessoku

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"io"
	"slices"
	"strconv"
	"strings"

	mystrings "github.com/mazrean/kessoku/internal/pkg/strings"
)

const (
	// maxInjectorReturnValues represents the maximum number of return values for an injector function
	maxInjectorReturnValues = 2
)

func Generate(w io.Writer, filename string, metaData *MetaData, injectors []*Injector) error {
	file := &ast.File{
		Name: ast.NewIdent(metaData.Package.Name),
	}

	// Generate injector function declarations and collect imports
	var funcDecls []ast.Decl
	for _, injector := range injectors {
		funcDecl, imports := generateInjectorDecl(injector)
		funcDecls = append(funcDecls, funcDecl)

		for _, importPath := range imports {
			if _, exists := metaData.Imports[importPath]; exists {
				continue
			}

			metaData.Imports[importPath] = &ast.ImportSpec{
				Path: &ast.BasicLit{
					Kind:  token.STRING,
					Value: strconv.Quote(importPath),
				},
			}
		}
	}

	// Generate import declaration first
	importSpecs := make([]*ast.ImportSpec, 0, len(metaData.Imports))
	for _, importSpec := range metaData.Imports {
		importSpecs = append(importSpecs, importSpec)
	}
	slices.SortFunc(importSpecs, func(a, b *ast.ImportSpec) int {
		return strings.Compare(a.Path.Value, b.Path.Value)
	})
	importDecl := generateImportDecl(importSpecs)
	if importDecl != nil {
		file.Decls = append(file.Decls, importDecl)
	}

	// Add function declarations after imports
	file.Decls = append(file.Decls, funcDecls...)

	// Add DO NOT EDIT comment
	_, err := w.Write([]byte(fmt.Sprintf("// Code generated by kessoku. DO NOT EDIT.\n\n")))
	if err != nil {
		return fmt.Errorf("write DO NOT EDIT comment: %w", err)
	}

	// Format and write the generated code
	err = format.Node(w, token.NewFileSet(), file)
	if err != nil {
		return fmt.Errorf("format generated code: %w", err)
	}

	return nil
}

// isContextType checks if a type is context.Context
func isContextType(t types.Type) bool {
	if named, ok := t.(*types.Named); ok {
		if obj := named.Obj(); obj != nil && obj.Pkg() != nil {
			return obj.Pkg().Path() == "context" && obj.Name() == "Context"
		}
	}

	return false
}

func generateImportDecl(imporSpecs []*ast.ImportSpec) *ast.GenDecl {
	specs := make([]ast.Spec, 0, len(imporSpecs))
	for _, importSpec := range imporSpecs {
		specs = append(specs, importSpec)
	}
	if len(specs) == 0 {
		return nil
	}

	return &ast.GenDecl{
		Tok:   token.IMPORT,
		Specs: specs,
	}
}

func generateInjectorDecl(injector *Injector) (ast.Decl, []string) {
	varPool := NewVarPool()
	paramFields := make([]*ast.Field, 0, len(injector.Args)+1)

	// Add parameters
	for _, arg := range injector.Args {
		if arg != nil && arg.ASTTypeExpr != nil && arg.Param != nil {
			paramFields = append(paramFields, &ast.Field{
				Names: []*ast.Ident{ast.NewIdent(arg.Param.Name(varPool))},
				Type:  arg.ASTTypeExpr,
			})
		}
	}

	// Return type - will be set in Results field
	resultsFields := make([]*ast.Field, 0, maxInjectorReturnValues)
	if injector.Return != nil && injector.Return.Return != nil && injector.Return.Return.ASTTypeExpr != nil {
		resultsFields = append(resultsFields, &ast.Field{
			Type: injector.Return.Return.ASTTypeExpr,
		})
	}
	if injector.IsReturnError {
		resultsFields = append(resultsFields, &ast.Field{
			Type: &ast.Ident{Name: "error"},
		})
	}

	var params *ast.FieldList
	if len(paramFields) > 0 {
		// Validate that all param fields have non-nil Type
		validParams := make([]*ast.Field, 0, len(paramFields))
		for _, field := range paramFields {
			if field != nil && field.Type != nil {
				validParams = append(validParams, field)
			}
		}
		if len(validParams) > 0 {
			params = &ast.FieldList{
				List: validParams,
			}
		}
	}

	var results *ast.FieldList
	if len(resultsFields) > 0 {
		// Validate that all result fields have non-nil Type
		validResults := make([]*ast.Field, 0, len(resultsFields))
		for _, field := range resultsFields {
			if field != nil && field.Type != nil {
				validResults = append(validResults, field)
			}
		}
		if len(validResults) > 0 {
			results = &ast.FieldList{
				List: validResults,
			}
		}
	}

	funcType := &ast.FuncType{
		Params:  params,
		Results: results,
	}

	stmts, imports := generateStmts(varPool, injector)

	funcDecl := &ast.FuncDecl{
		Name: ast.NewIdent(injector.Name),
		Type: funcType,
		Body: &ast.BlockStmt{
			List: stmts,
		},
	}

	return funcDecl, imports
}

// generateStmts generates statements with parallel execution support using errgroup
func generateStmts(varPool *VarPool, injector *Injector) ([]ast.Stmt, []string) {
	var stmts []ast.Stmt
	var imports []string

	hasAsyncChains := false
	for _, stmt := range injector.Stmts {
		if stmt.HasAsync() {
			hasAsyncChains = true
			break
		}
	}

	// If there are async chains, create errgroup at the beginning
	if hasAsyncChains {
		imports = append(imports, "golang.org/x/sync/errgroup")

		hasCtx := false
		for _, arg := range injector.Args {
			hasCtx = isContextType(arg.Type)
			if hasCtx {
				break
			}
		}

		// Generate: eg, ctx := errgroup.WithContext(ctx)
		var egDecl *ast.AssignStmt
		if hasCtx {
			egDecl = &ast.AssignStmt{
				Lhs: []ast.Expr{
					ast.NewIdent("eg"),
					ast.NewIdent("ctx"),
				},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{
					&ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   ast.NewIdent("errgroup"),
							Sel: ast.NewIdent("WithContext"),
						},
						Args: []ast.Expr{ast.NewIdent("ctx")},
					},
				},
			}
		} else {
			egDecl = &ast.AssignStmt{
				Lhs: []ast.Expr{ast.NewIdent("eg")},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{
					&ast.UnaryExpr{
						Op: token.AND,
						X: &ast.CompositeLit{
							Type: &ast.SelectorExpr{
								X:   ast.NewIdent("errgroup"),
								Sel: ast.NewIdent("Group"),
							},
						},
					},
				},
			}
		}

		stmts = append(stmts, egDecl)
	}

	var returnErrStmts []ast.Stmt
	if injector.Return != nil && injector.Return.Return != nil && injector.Return.Return.ASTTypeExpr != nil {
		returnErrStmts = []ast.Stmt{
			&ast.DeclStmt{
				Decl: &ast.GenDecl{
					Tok: token.VAR,
					Specs: []ast.Spec{
						&ast.ValueSpec{
							Names: []*ast.Ident{ast.NewIdent("zero")},
							Type:  injector.Return.Return.ASTTypeExpr,
						},
					},
				},
			},
			&ast.ReturnStmt{
				Results: []ast.Expr{ast.NewIdent("zero"), ast.NewIdent("err")},
			},
		}
	} else {
		returnErrStmts = []ast.Stmt{
			&ast.ReturnStmt{
				Results: []ast.Expr{ast.NewIdent("err")},
			},
		}
	}

	// Process statements and collect completion channels
	for _, stmt := range injector.Stmts {
		newStmts, newImports := stmt.Stmt(varPool, injector, returnErrStmts)
		imports = append(imports, newImports...)
		stmts = append(stmts, newStmts...)
	}

	// If there are async chains, wait for all goroutines to complete
	if hasAsyncChains {
		// Generate error handling: if err := eg.Wait(); err != nil { return nil, err }
		if injector.IsReturnError {
			waitErrorStmt := &ast.IfStmt{
				Init: &ast.AssignStmt{
					Lhs: []ast.Expr{ast.NewIdent("err")},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("eg"),
								Sel: ast.NewIdent("Wait"),
							},
						},
					},
				},
				Cond: &ast.BinaryExpr{
					X:  ast.NewIdent("err"),
					Op: token.NEQ,
					Y:  ast.NewIdent("nil"),
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.ReturnStmt{
							Results: []ast.Expr{
								ast.NewIdent("nil"),
								ast.NewIdent("err"),
							},
						},
					},
				},
			}
			stmts = append(stmts, waitErrorStmt)
		} else {
			// Just wait for completion without error handling
			waitStmt := &ast.ExprStmt{
				X: &ast.CallExpr{
					Fun: &ast.SelectorExpr{
						X:   ast.NewIdent("eg"),
						Sel: ast.NewIdent("Wait"),
					},
				},
			}
			stmts = append(stmts, waitStmt)
		}
	}

	// Add return statement
	returnExprs := make([]ast.Expr, 0, maxInjectorReturnValues)
	if injector.Return != nil && injector.Return.Param != nil {
		returnExprs = append(returnExprs, ast.NewIdent(injector.Return.Param.Name(varPool)))
	}
	if injector.IsReturnError {
		returnExprs = append(returnExprs, ast.NewIdent("nil"))
	}
	if len(returnExprs) > 0 {
		stmts = append(stmts, &ast.ReturnStmt{
			Results: returnExprs,
		})
	}

	return stmts, imports
}

func (stmt *InjectorProviderCallStmt) Stmt(varPool *VarPool, injector *Injector, returnErrStmts []ast.Stmt) ([]ast.Stmt, []string) {
	var stmts []ast.Stmt

	lhs := make([]ast.Expr, 0, len(stmt.Returns)+1)
	for _, ret := range stmt.Returns {
		if ret != nil {
			lhs = append(lhs, &ast.Ident{
				Name: ret.Name(varPool),
			})
		}
	}
	if stmt.Provider.IsReturnError {
		lhs = append(lhs, &ast.Ident{
			Name: "err",
		})
	}

	args := make([]ast.Expr, 0, len(stmt.Arguments))
	for _, arg := range stmt.Arguments {
		if arg != nil && arg.Param != nil {
			args = append(args, ast.NewIdent(arg.Param.Name(varPool)))
		}
	}

	channels := make([]ast.Expr, 0, len(stmt.Arguments))
	for _, arg := range stmt.Arguments {
		if arg != nil && arg.Param != nil && arg.IsWait {
			channels = append(channels, ast.NewIdent(arg.Param.ChannelName(varPool)))
		}
	}

	if len(channels) > 0 {
		stmts = append(stmts, stmt.channelsWait(channels))
	}

	// Generate call to provider.Fn()() - call the Fn method, then call the returned function
	var rhs ast.Expr
	if stmt.Provider.ASTExpr != nil {
		rhs = &ast.CallExpr{
			Fun: &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   stmt.Provider.ASTExpr,
					Sel: ast.NewIdent("Fn"),
				},
				Args: []ast.Expr{},
			},
			Args: args,
		}
	} else {
		// Fallback if ASTExpr is nil
		rhs = &ast.CallExpr{
			Fun:  ast.NewIdent("nil"),
			Args: args,
		}
	}

	stmts = append(stmts, &ast.AssignStmt{
		Tok: token.DEFINE,
		Lhs: lhs,
		Rhs: []ast.Expr{rhs},
	})

	if stmt.Provider.IsReturnError {
		stmts = append(stmts, &ast.IfStmt{
			Cond: &ast.BinaryExpr{
				X:  ast.NewIdent("err"),
				Op: token.NEQ,
				Y:  ast.NewIdent("nil"),
			},
			Body: &ast.BlockStmt{
				List: returnErrStmts,
			},
		})
	}

	resultChannels := make([]ast.Expr, 0, len(stmt.Returns))
	for _, ret := range stmt.Returns {
		if ret != nil && ret.withChannel {
			resultChannels = append(resultChannels, ast.NewIdent(ret.ChannelName(varPool)))
		}
	}

	if len(resultChannels) > 0 {
		stmts = append(stmts, stmt.channelsClose(resultChannels))
	}

	return stmts, nil
}

func (stmt *InjectorProviderCallStmt) channelsWait(channels []ast.Expr) ast.Stmt {
	/*
		ast of:
		for _, ch := range []<-chan struct{}{v1, v2, v3} {
			select {
			case <-ch:
			case <-ctx.Done():
				return ctx.Err()
			}
		}
	*/
	return &ast.RangeStmt{
		Tok:   token.DEFINE,
		Key:   ast.NewIdent("_"),
		Value: ast.NewIdent("ch"),
		X: &ast.CompositeLit{
			Type: &ast.ArrayType{
				Elt: &ast.ChanType{
					Dir: ast.RECV,
					Value: &ast.StructType{
						Fields: &ast.FieldList{List: []*ast.Field{}},
					},
				},
			},
			Elts: channels,
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.SelectStmt{
					Body: &ast.BlockStmt{
						List: []ast.Stmt{
							&ast.CaseClause{
								List: []ast.Expr{
									&ast.UnaryExpr{
										Op: token.ARROW,
										X:  ast.NewIdent("ch"),
									},
								},
								Body: []ast.Stmt{},
							},
							&ast.CaseClause{
								List: []ast.Expr{
									&ast.UnaryExpr{
										Op: token.ARROW,
										X: &ast.SelectorExpr{
											X:   ast.NewIdent("ctx"),
											Sel: ast.NewIdent("Done"),
										},
									},
								},
								Body: []ast.Stmt{
									&ast.ReturnStmt{
										Results: []ast.Expr{
											&ast.CallExpr{
												Fun: &ast.SelectorExpr{
													X:   ast.NewIdent("ctx"),
													Sel: ast.NewIdent("Err"),
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func (stmt *InjectorProviderCallStmt) channelsClose(channels []ast.Expr) ast.Stmt {
	/*
		ast of:
		for _, ch := range []<-chan struct{}{v1, v2, v3} {
			close(ch)
		}
	*/
	return &ast.RangeStmt{
		Tok:   token.DEFINE,
		Key:   ast.NewIdent("_"),
		Value: ast.NewIdent("ch"),
		X: &ast.CompositeLit{
			Type: &ast.ArrayType{
				Elt: &ast.ChanType{
					Dir: ast.SEND,
					Value: &ast.StructType{
						Fields: &ast.FieldList{List: []*ast.Field{}},
					},
				},
			},
			Elts: channels,
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: ast.NewIdent("close"),
						Args: []ast.Expr{
							ast.NewIdent("ch"),
						},
					},
				},
			},
		},
	}
}

var chainReturnErrStmts = []ast.Stmt{
	&ast.ReturnStmt{
		Results: []ast.Expr{ast.NewIdent("err")},
	},
}

func (stmt *InjectorChainStmt) Stmt(varPool *VarPool, injector *Injector, _ []ast.Stmt) ([]ast.Stmt, []string) {
	var imports []string

	stmts := []ast.Stmt{
		&ast.DeclStmt{
			Decl: &ast.GenDecl{
				Tok: token.VAR,
				Specs: []ast.Spec{
					&ast.ValueSpec{
						Names: []*ast.Ident{ast.NewIdent("err")},
						Type:  &ast.Ident{Name: "error"},
					},
				},
			},
		},
	}

	// Generate sequential execution for sync chains
	for _, chainStmt := range stmt.Statements {
		chainStmts, chainImports := chainStmt.Stmt(varPool, injector, chainReturnErrStmts)
		stmts = append(stmts, chainStmts...)
		imports = append(imports, chainImports...)
	}

	stmts = append(stmts, &ast.ReturnStmt{
		Results: []ast.Expr{ast.NewIdent("nil")},
	})

	return []ast.Stmt{
		&ast.ExprStmt{
			X: &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   ast.NewIdent("eg"),
					Sel: ast.NewIdent("Go"),
				},
				Args: []ast.Expr{
					&ast.FuncLit{
						Type: &ast.FuncType{
							Params: nil, // Empty parameter list
							Results: &ast.FieldList{
								List: []*ast.Field{
									{
										Type: &ast.Ident{Name: "error"},
									},
								},
							},
						},
						Body: &ast.BlockStmt{
							List: stmts,
						},
					},
				},
			},
		},
	}, imports
}

type VarPool struct {
	vars map[string]int
}

func NewVarPool() *VarPool {
	return &VarPool{
		vars: make(map[string]int),
	}
}

func (p *VarPool) Get(t types.Type) string {
	name := p.getBaseName(t)

	count, ok := p.vars[name]
	if !ok {
		count = 0
	}
	p.vars[name] = count + 1

	if count == 0 {
		return name
	}

	return fmt.Sprintf("%s%d", name, count-1)
}

func (p *VarPool) GetChannel(t types.Type) string {
	name := p.getBaseName(t) + "Ch"

	count, ok := p.vars[name]
	if !ok {
		count = 0
	}
	p.vars[name] = count + 1

	if count == 0 {
		return name
	}

	return fmt.Sprintf("%s%d", name, count-1)
}

// getTypeBaseName extracts a base name from a type for argument naming
func (p *VarPool) getBaseName(t types.Type) string {
	// For pointers, recurse on the element type
	for ptr, ok := t.(*types.Pointer); ok; ptr, ok = t.(*types.Pointer) {
		t = ptr.Elem()
	}

	switch t := t.(type) {
	case *types.Named:
		if obj := t.Obj(); obj != nil && obj.Pkg() != nil {
			if obj.Pkg().Path() == "context" && obj.Name() == "Context" {
				return "ctx"
			}
		}

		return mystrings.ToLowerCamel(t.Obj().Name())
	case *types.Basic:
		// Check by kind for all basic types (byte and rune are handled by their underlying types)
		switch t.Kind() {
		case types.Int, types.Int8, types.Int16, types.Int32, types.Int64,
			types.Uint, types.Uint8, types.Uint16, types.Uint32, types.Uint64,
			types.Float32, types.Float64,
			types.UntypedInt, types.UntypedFloat, types.UntypedRune:
			return "num"
		case types.String, types.UntypedString:
			return "str"
		case types.Bool, types.UntypedBool:
			return "flag"
		case types.Complex64, types.Complex128, types.UntypedComplex:
			return "complex"
		case types.Uintptr, types.UnsafePointer:
			return "ptr"
		case types.UntypedNil:
			return "null"
		case types.Invalid:
			return "invalid"
		default:
			return mystrings.ToLowerCamel(t.Name())
		}
	}

	return "val"
}
