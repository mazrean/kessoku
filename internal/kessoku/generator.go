package kessoku

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"io"
	"slices"
	"strings"
)

const (
	// maxInjectorReturnValues represents the maximum number of return values for an injector function
	maxInjectorReturnValues = 2
)

func Generate(w io.Writer, filename string, metaData *MetaData, injectors []*Injector) error {
	// Add context import if any injector has context.Context arguments
	hasContextArgs := false
	for _, injector := range injectors {
		for _, arg := range injector.Args {
			if arg.Arg.Type.String() == "context.Context" {
				hasContextArgs = true
				break
			}
		}
		if hasContextArgs {
			break
		}
	}

	if hasContextArgs {
		// Add context import if not already present
		if _, exists := metaData.Imports["context"]; !exists {
			metaData.Imports["context"] = &ast.ImportSpec{
				Path: &ast.BasicLit{
					Kind:  token.STRING,
					Value: "\"context\"",
				},
			}
		}
	}

	file := &ast.File{
		Name: ast.NewIdent(metaData.Package),
	}

	// Generate import declaration
	importSpecs := make([]*ast.ImportSpec, 0, len(metaData.Imports))
	for _, importSpec := range metaData.Imports {
		importSpecs = append(importSpecs, importSpec)
	}
	slices.SortFunc(importSpecs, func(a, b *ast.ImportSpec) int {
		return strings.Compare(a.Path.Value, b.Path.Value)
	})
	importDecl := generateImportDecl(importSpecs)
	if importDecl != nil {
		file.Decls = append(file.Decls, importDecl)
	}

	// Generate injector function declarations
	for _, injector := range injectors {
		file.Decls = append(file.Decls, generateInjectorDecl(injector))
	}

	// Add DO NOT EDIT comment
	_, err := w.Write([]byte(fmt.Sprintf("// Code generated by kessoku. DO NOT EDIT.\n\n")))
	if err != nil {
		return fmt.Errorf("write DO NOT EDIT comment: %w", err)
	}

	// Format and write the generated code
	err = format.Node(w, token.NewFileSet(), file)
	if err != nil {
		return fmt.Errorf("format generated code: %w", err)
	}

	return nil
}

func generateImportDecl(imporSpecs []*ast.ImportSpec) *ast.GenDecl {
	specs := make([]ast.Spec, 0, len(imporSpecs))
	for _, importSpec := range imporSpecs {
		specs = append(specs, importSpec)
	}
	if len(specs) == 0 {
		return nil
	}

	return &ast.GenDecl{
		Tok:   token.IMPORT,
		Specs: specs,
	}
}

func generateInjectorDecl(injector *Injector) ast.Decl {
	paramFields := make([]*ast.Field, 0, len(injector.Args)+1)

	// Add context.Context parameter for async providers if needed
	hasAsyncProviders := false
	for _, stmt := range injector.Stmts {
		if stmt.HasAsync() {
			hasAsyncProviders = true
			break
		}
	}

	if hasAsyncProviders {
		paramFields = append(paramFields, &ast.Field{
			Names: []*ast.Ident{ast.NewIdent("ctx")},
			Type: &ast.SelectorExpr{
				X:   ast.NewIdent("context"),
				Sel: ast.NewIdent("Context"),
			},
		})
	}

	// Add parameters
	for _, arg := range injector.Args {
		paramFields = append(paramFields, &ast.Field{
			Names: []*ast.Ident{ast.NewIdent(arg.Param.Name())},
			Type:  arg.Arg.ASTTypeExpr,
		})
	}

	// Return type - will be set in Results field

	var resultsFields []*ast.Field
	if injector.IsReturnError {
		resultsFields = []*ast.Field{
			{
				Type: injector.Return.Return.ASTTypeExpr,
			},
			{
				Type: &ast.Ident{Name: "error"},
			},
		}
	} else {
		resultsFields = []*ast.Field{
			{
				Type: injector.Return.Return.ASTTypeExpr,
			},
		}
	}

	funcType := &ast.FuncType{
		Params: &ast.FieldList{
			List: paramFields,
		},
		Results: &ast.FieldList{
			List: resultsFields,
		},
	}

	funcDecl := &ast.FuncDecl{
		Name: ast.NewIdent(injector.Name),
		Type: funcType,
		Body: &ast.BlockStmt{
			List: generateStmts(injector),
		},
	}

	return funcDecl
}

// generateStmts generates statements with parallel execution support using errgroup
func generateStmts(injector *Injector) []ast.Stmt {
	var stmts []ast.Stmt

	// Process statements using the new chain-based approach
	for _, stmt := range injector.Stmts {
		stmts = append(stmts, stmt.Stmt(injector)...)
	}

	// Add return statement
	if injector.Return != nil {
		returnExprs := []ast.Expr{ast.NewIdent(injector.Return.Param.Name())}
		if injector.IsReturnError {
			returnExprs = append(returnExprs, ast.NewIdent("nil"))
		}
		stmts = append(stmts, &ast.ReturnStmt{
			Results: returnExprs,
		})
	}

	return stmts
}
