package kessoku

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"io"
)

const (
	// maxInjectorReturnValues represents the maximum number of return values for an injector function
	maxInjectorReturnValues = 2
)

func Generate(w io.Writer, filename string, metaData *MetaData, injectors []*Injector) error {
	// Check if any injector needs errgroup and context imports and add them
	for _, injector := range injectors {
		hasAsyncProviders := false
		for _, stmt := range injector.Stmts {
			if stmt.ParallelGroup > 0 {
				// Count how many statements are in the same parallel group
				sameGroupCount := 0
				for _, otherStmt := range injector.Stmts {
					if otherStmt.ParallelGroup == stmt.ParallelGroup {
						sameGroupCount++
					}
				}
				if sameGroupCount > 1 {
					hasAsyncProviders = true
					break
				}
			}
		}
		
		if hasAsyncProviders {
			// Add errgroup import if not already present
			if _, exists := metaData.Imports["golang.org/x/sync/errgroup"]; !exists {
				metaData.Imports["golang.org/x/sync/errgroup"] = &ast.ImportSpec{
					Path: &ast.BasicLit{
						Kind:  token.STRING,
						Value: "\"golang.org/x/sync/errgroup\"",
					},
				}
			}
			// Add context import if not already present
			if _, exists := metaData.Imports["context"]; !exists {
				metaData.Imports["context"] = &ast.ImportSpec{
					Path: &ast.BasicLit{
						Kind:  token.STRING,
						Value: "\"context\"",
					},
				}
			}
			break
		}
	}

	// Convert imports map to slice
	importSpecs := make([]*ast.ImportSpec, 0, len(metaData.Imports))
	for _, imp := range metaData.Imports {
		importSpecs = append(importSpecs, imp)
	}

	astFile := &ast.File{
		Name: &ast.Ident{
			Name: metaData.Package,
		},
		Imports: importSpecs,
		Decls:   make([]ast.Decl, 0, len(injectors)+1),
	}

	importDecl := generateImportDecl(importSpecs)
	if importDecl != nil {
		astFile.Decls = append(astFile.Decls, importDecl)
	}

	for _, injector := range injectors {
		astFile.Decls = append(astFile.Decls, generateInjectorDecl(injector))
	}

	_, err := w.Write([]byte("// Code generated by kessoku. DO NOT EDIT.\n\n"))
	if err != nil {
		return fmt.Errorf("write code: %w", err)
	}

	err = format.Node(w, token.NewFileSet(), astFile)
	if err != nil {
		return fmt.Errorf("format node: %w", err)
	}

	return nil
}

func generateImportDecl(imporSpecs []*ast.ImportSpec) *ast.GenDecl {
	specs := make([]ast.Spec, 0, len(imporSpecs))
	for _, importSpec := range imporSpecs {
		specs = append(specs, importSpec)
	}
	if len(specs) == 0 {
		return nil
	}

	return &ast.GenDecl{
		Tok:   token.IMPORT,
		Specs: specs,
	}
}

func generateInjectorDecl(injector *Injector) ast.Decl {
	paramFields := make([]*ast.Field, 0, len(injector.Args)+1)
	
	// Add context.Context parameter for async providers if needed
	hasAsyncProviders := false
	for _, stmt := range injector.Stmts {
		if stmt.ParallelGroup > 0 {
			sameGroupCount := 0
			for _, otherStmt := range injector.Stmts {
				if otherStmt.ParallelGroup == stmt.ParallelGroup {
					sameGroupCount++
				}
			}
			if sameGroupCount > 1 {
				hasAsyncProviders = true
				break
			}
		}
	}
	
	if hasAsyncProviders && !injector.HasExistingContext {
		paramFields = append(paramFields, &ast.Field{
			Names: []*ast.Ident{ast.NewIdent(injector.ContextParamName)},
			Type: &ast.SelectorExpr{
				X:   ast.NewIdent("context"),
				Sel: ast.NewIdent("Context"),
			},
		})
	}

	for _, arg := range injector.Args {
		paramFields = append(paramFields, &ast.Field{
			Names: []*ast.Ident{ast.NewIdent(arg.Param.Name())},
			Type:  arg.Arg.ASTTypeExpr,
		})
	}

	resultFields := make([]*ast.Field, 0, maxInjectorReturnValues)
	if injector.Return != nil && injector.Return.Return != nil {
		resultFields = append(resultFields, &ast.Field{
			Type: injector.Return.Return.ASTTypeExpr,
		})
	} else {
		// Fallback for missing return type
		resultFields = append(resultFields, &ast.Field{
			Type: ast.NewIdent("interface{}"),
		})
	}
	if injector.IsReturnError {
		resultFields = append(resultFields, &ast.Field{
			Type: ast.NewIdent("error"),
		})
	}

	stmts := generateStmtsWithParallelization(injector)

	returns := make([]ast.Expr, 0, maxInjectorReturnValues)
	if injector.Return != nil && injector.Return.Param != nil {
		returns = append(returns, ast.NewIdent(injector.Return.Param.Name()))
	} else {
		// Fallback for missing return param
		returns = append(returns, ast.NewIdent("nil"))
	}
	if injector.IsReturnError {
		returns = append(returns, ast.NewIdent("nil"))
	}

	stmts = append(stmts, &ast.ReturnStmt{
		Results: returns,
	})

	funcDecl := &ast.FuncDecl{
		Name: ast.NewIdent(injector.Name),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: paramFields,
			},
			Results: &ast.FieldList{
				List: resultFields,
			},
		},
		Body: &ast.BlockStmt{
			List: stmts,
		},
	}

	return funcDecl
}

// getReturnTypeExpr safely gets the return type expression with fallback
func getReturnTypeExpr(injector *Injector) ast.Expr {
	if injector.Return != nil && injector.Return.Return != nil {
		return injector.Return.Return.ASTTypeExpr
	}
	return ast.NewIdent("interface{}")
}

// generateStmtsWithParallelization generates statements with parallel execution support using errgroup
func generateStmtsWithParallelization(injector *Injector) []ast.Stmt {
	var stmts []ast.Stmt
	
	// Group statements by parallel group
	parallelGroups := make(map[int][]*InjectorStmt)
	for _, stmt := range injector.Stmts {
		parallelGroups[stmt.ParallelGroup] = append(parallelGroups[stmt.ParallelGroup], stmt)
	}
	
	// Check if we need errgroup imports
	hasParallelGroups := false
	for groupID, group := range parallelGroups {
		if groupID > 0 && len(group) > 1 {
			hasParallelGroups = true
			break
		}
	}
	
	// Track if errgroup variables have been declared
	errgroupDeclared := false
	
	// Process statements in the order they appear in injector.Stmts
	// This preserves the dependency order established by the topological sort
	processedGroups := make(map[int]bool)
	for _, stmt := range injector.Stmts {
		groupID := stmt.ParallelGroup
		
		// Process sequential statements immediately 
		if groupID == 0 {
			stmts = append(stmts, generateSequentialStmt(stmt, injector)...)
			continue
		}
		
		// For parallel statements, process the entire group when first encountered
		if !processedGroups[groupID] {
			processedGroups[groupID] = true
			group := parallelGroups[groupID]
			if len(group) == 1 {
				// Single statement (async or not) - execute synchronously to avoid unnecessary goroutine
				stmts = append(stmts, generateSequentialStmt(stmt, injector)...)
			} else {
				// Multiple statements - check if execution plan exists for optimized channel-based execution
				if plan, exists := injector.ExecutionPlans[groupID]; exists {
					// Use optimized channel-based execution with reduced goroutines
					stmts = append(stmts, generateOptimizedParallelStmtsWithReduction(plan, injector, hasParallelGroups, errgroupDeclared)...)
					errgroupDeclared = true
				} else {
					// Fallback to simple parallel execution with reduced goroutines
					stmts = append(stmts, generateParallelStmtsWithReduction(group, injector, hasParallelGroups, errgroupDeclared)...)
					errgroupDeclared = true
				}
			}
		}
	}
	
	return stmts
}


// generateSequentialStmt generates a sequential statement
func generateSequentialStmt(stmt *InjectorStmt, injector *Injector) []ast.Stmt {
	var stmts []ast.Stmt
	
	lhs := make([]ast.Expr, 0, len(stmt.Returns)+1)
	for _, ret := range stmt.Returns {
		lhs = append(lhs, &ast.Ident{
			Name: ret.Name(),
		})
	}
	if stmt.Provider.IsReturnError {
		lhs = append(lhs, &ast.Ident{
			Name: "err",
		})
	}

	args := make([]ast.Expr, 0, len(stmt.Arguments))
	for _, arg := range stmt.Arguments {
		args = append(args, ast.NewIdent(arg.Name()))
	}

	rhs := &ast.CallExpr{
		Fun: &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   stmt.Provider.ASTExpr,
				Sel: ast.NewIdent("Fn"),
			},
			Args: []ast.Expr{},
		},
		Args: args,
	}

	stmts = append(stmts, &ast.AssignStmt{
		Tok: token.DEFINE,
		Lhs: lhs,
		Rhs: []ast.Expr{rhs},
	})

	if stmt.Provider.IsReturnError {
		stmts = append(stmts, &ast.IfStmt{
			Cond: &ast.BinaryExpr{
				X:  ast.NewIdent("err"),
				Op: token.NEQ,
				Y:  ast.NewIdent("nil"),
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.DeclStmt{
						Decl: &ast.GenDecl{
							Tok: token.VAR,
							Specs: []ast.Spec{
								&ast.ValueSpec{
									Names: []*ast.Ident{ast.NewIdent("zero")},
									Type:  getReturnTypeExpr(injector),
								},
							},
						},
					},
					&ast.ReturnStmt{
						Results: []ast.Expr{
							ast.NewIdent("zero"),
							ast.NewIdent("err"),
						},
					},
				},
			},
		})
	}
	
	return stmts
}


// generateErrgroupGoroutine generates a goroutine for errgroup
func generateErrgroupGoroutine(stmt *InjectorStmt) ast.Stmt {
	args := make([]ast.Expr, 0, len(stmt.Arguments))
	for _, arg := range stmt.Arguments {
		args = append(args, ast.NewIdent(arg.Name()))
	}

	rhs := &ast.CallExpr{
		Fun: &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   stmt.Provider.ASTExpr,
				Sel: ast.NewIdent("Fn"),
			},
			Args: []ast.Expr{},
		},
		Args: args,
	}
	
	// Create the function body for the goroutine
	goroutineBody := []ast.Stmt{
		// Check context cancellation first
		&ast.IfStmt{
			Cond: &ast.BinaryExpr{
				X: &ast.CallExpr{
					Fun: &ast.SelectorExpr{
						X:   ast.NewIdent("ctx"),
						Sel: ast.NewIdent("Err"),
					},
				},
				Op: token.NEQ,
				Y:  ast.NewIdent("nil"),
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ReturnStmt{
						Results: []ast.Expr{
							&ast.CallExpr{
								Fun: &ast.SelectorExpr{
									X:   ast.NewIdent("ctx"),
									Sel: ast.NewIdent("Err"),
								},
							},
						},
					},
				},
			},
		},
		// Execute the provider function
		&ast.AssignStmt{
			Tok: token.DEFINE,
			Lhs: []ast.Expr{ast.NewIdent("result")},
			Rhs: []ast.Expr{rhs},
		},
	}
	
	// Add assignment to result variable
	for i, ret := range stmt.Returns {
		if i == 0 { // Simplified: only handle first return value for now
			goroutineBody = append(goroutineBody, &ast.AssignStmt{
				Tok: token.ASSIGN,
				Lhs: []ast.Expr{ast.NewIdent(ret.Name())},
				Rhs: []ast.Expr{ast.NewIdent("result")},
			})
		}
	}
	
	goroutineBody = append(goroutineBody, &ast.ReturnStmt{
		Results: []ast.Expr{ast.NewIdent("nil")},
	})
	
	return &ast.ExprStmt{
		X: &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("g"),
				Sel: ast.NewIdent("Go"),
			},
			Args: []ast.Expr{
				&ast.FuncLit{
					Type: &ast.FuncType{
						Results: &ast.FieldList{
							List: []*ast.Field{
								{Type: ast.NewIdent("error")},
							},
						},
					},
					Body: &ast.BlockStmt{
						List: goroutineBody,
					},
				},
			},
		},
	}
}


// generateParallelStmtsWithReduction generates parallel statements with reduced goroutine count
func generateParallelStmtsWithReduction(group []*InjectorStmt, injector *Injector, needsErrgroup bool, errgroupDeclared bool) []ast.Stmt {
	var stmts []ast.Stmt
	
	// Separate first statement for main thread execution
	var mainThreadStmt *InjectorStmt
	var goroutineStmts []*InjectorStmt
	
	if len(group) > 0 {
		mainThreadStmt = group[0]
		if len(group) > 1 {
			goroutineStmts = group[1:]
		}
	}
	
	if needsErrgroup && len(goroutineStmts) > 0 {
		// Create or reassign errgroup with context
		tok := token.DEFINE
		if errgroupDeclared {
			tok = token.ASSIGN
		}
		stmts = append(stmts, &ast.AssignStmt{
			Tok: tok,
			Lhs: []ast.Expr{ast.NewIdent("g"), ast.NewIdent("ctx")},
			Rhs: []ast.Expr{
				&ast.CallExpr{
					Fun: &ast.SelectorExpr{
						X:   ast.NewIdent("errgroup"),
						Sel: ast.NewIdent("WithContext"),
					},
					Args: []ast.Expr{ast.NewIdent(injector.ContextParamName)},
				},
			},
		})
	}
	
	// Declare result variables for all statements
	for _, stmt := range group {
		for i, ret := range stmt.Returns {
			if i < len(stmt.Provider.Provides) {
				// Use the actual provider type for this return value
				providerReturnType, _ := createASTTypeExpr(stmt.Provider.Provides[i])
				stmts = append(stmts, &ast.DeclStmt{
					Decl: &ast.GenDecl{
						Tok: token.VAR,
						Specs: []ast.Spec{
							&ast.ValueSpec{
								Names: []*ast.Ident{ast.NewIdent(ret.Name())},
								Type:  providerReturnType,
							},
						},
					},
				})
			}
		}
	}
	
	// Execute main thread statement first
	if mainThreadStmt != nil {
		stmts = append(stmts, generateInlineStmt(mainThreadStmt)...)
	}
	
	// Generate goroutines for remaining statements
	for _, stmt := range goroutineStmts {
		if needsErrgroup {
			stmts = append(stmts, generateErrgroupGoroutine(stmt))
		}
	}
	
	if needsErrgroup && len(goroutineStmts) > 0 {
		// Wait for all goroutines
		stmts = append(stmts, &ast.IfStmt{
			Init: &ast.AssignStmt{
				Tok: token.DEFINE,
				Lhs: []ast.Expr{ast.NewIdent("err")},
				Rhs: []ast.Expr{
					&ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   ast.NewIdent("g"),
							Sel: ast.NewIdent("Wait"),
						},
					},
				},
			},
			Cond: &ast.BinaryExpr{
				X:  ast.NewIdent("err"),
				Op: token.NEQ,
				Y:  ast.NewIdent("nil"),
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.DeclStmt{
						Decl: &ast.GenDecl{
							Tok: token.VAR,
							Specs: []ast.Spec{
								&ast.ValueSpec{
									Names: []*ast.Ident{ast.NewIdent("zero")},
									Type:  getReturnTypeExpr(injector),
								},
							},
						},
					},
					&ast.ReturnStmt{
						Results: []ast.Expr{
							ast.NewIdent("zero"),
							ast.NewIdent("err"),
						},
					},
				},
			},
		})
	}
	
	return stmts
}

// generateInlineStmt generates an inline statement execution (without goroutine)
func generateInlineStmt(stmt *InjectorStmt) []ast.Stmt {
	var stmts []ast.Stmt
	
	lhs := make([]ast.Expr, 0, len(stmt.Returns)+1)
	for _, ret := range stmt.Returns {
		lhs = append(lhs, &ast.Ident{
			Name: ret.Name(),
		})
	}
	if stmt.Provider.IsReturnError {
		lhs = append(lhs, &ast.Ident{
			Name: "err",
		})
	}

	args := make([]ast.Expr, 0, len(stmt.Arguments))
	for _, arg := range stmt.Arguments {
		args = append(args, ast.NewIdent(arg.Name()))
	}

	rhs := &ast.CallExpr{
		Fun: &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   stmt.Provider.ASTExpr,
				Sel: ast.NewIdent("Fn"),
			},
			Args: []ast.Expr{},
		},
		Args: args,
	}

	stmts = append(stmts, &ast.AssignStmt{
		Tok: token.ASSIGN,
		Lhs: lhs,
		Rhs: []ast.Expr{rhs},
	})

	if stmt.Provider.IsReturnError {
		stmts = append(stmts, &ast.IfStmt{
			Cond: &ast.BinaryExpr{
				X:  ast.NewIdent("err"),
				Op: token.NEQ,
				Y:  ast.NewIdent("nil"),
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.DeclStmt{
						Decl: &ast.GenDecl{
							Tok: token.VAR,
							Specs: []ast.Spec{
								&ast.ValueSpec{
									Names: []*ast.Ident{ast.NewIdent("zero")},
									Type:  ast.NewIdent("*App"), // This should be dynamic based on return type
								},
							},
						},
					},
					&ast.ReturnStmt{
						Results: []ast.Expr{
							ast.NewIdent("zero"),
							ast.NewIdent("err"),
						},
					},
				},
			},
		})
	}
	
	return stmts
}

// generateOptimizedParallelStmtsWithReduction generates optimized parallel execution with reduced goroutines
func generateOptimizedParallelStmtsWithReduction(plan *ParallelExecutionPlan, injector *Injector, needsErrgroup bool, errgroupDeclared bool) []ast.Stmt {
	var stmts []ast.Stmt
	
	// If there's only one chain, execute it inline
	if len(plan.Chains) <= 1 {
		for _, chain := range plan.Chains {
			for _, stmt := range chain.Statements {
				stmts = append(stmts, generateInlineStmt(stmt)...)
			}
		}
		return stmts
	}
	
	// Separate first chain for main thread execution
	var mainThreadChain *DependencyChain
	var goroutineChains []*DependencyChain
	
	if len(plan.Chains) > 0 {
		mainThreadChain = plan.Chains[0]
		if len(plan.Chains) > 1 {
			goroutineChains = plan.Chains[1:]
		}
	}
	
	if needsErrgroup && len(goroutineChains) > 0 {
		// Create or reassign errgroup with context
		tok := token.DEFINE
		if errgroupDeclared {
			tok = token.ASSIGN
		}
		stmts = append(stmts, &ast.AssignStmt{
			Tok: tok,
			Lhs: []ast.Expr{ast.NewIdent("g"), ast.NewIdent("ctx")},
			Rhs: []ast.Expr{
				&ast.CallExpr{
					Fun: &ast.SelectorExpr{
						X:   ast.NewIdent("errgroup"),
						Sel: ast.NewIdent("WithContext"),
					},
					Args: []ast.Expr{ast.NewIdent(injector.ContextParamName)},
				},
			},
		})
	}
	
	// Create channels for cross-chain communication
	stmts = append(stmts, generateChannelDeclarations(plan)...)
	
	// Declare result variables for all statements
	stmts = append(stmts, generateResultVariableDeclarations(plan)...)
	
	// Execute main thread chain first
	if mainThreadChain != nil {
		for _, stmt := range mainThreadChain.Statements {
			stmts = append(stmts, generateInlineStmt(stmt)...)
		}
	}
	
	// Generate goroutines for remaining chains
	for _, chain := range goroutineChains {
		if needsErrgroup {
			stmts = append(stmts, generateChainGoroutine(chain))
		}
	}
	
	if needsErrgroup && len(goroutineChains) > 0 {
		// Wait for all goroutines
		stmts = append(stmts, &ast.IfStmt{
			Init: &ast.AssignStmt{
				Tok: token.DEFINE,
				Lhs: []ast.Expr{ast.NewIdent("err")},
				Rhs: []ast.Expr{
					&ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   ast.NewIdent("g"),
							Sel: ast.NewIdent("Wait"),
						},
					},
				},
			},
			Cond: &ast.BinaryExpr{
				X:  ast.NewIdent("err"),
				Op: token.NEQ,
				Y:  ast.NewIdent("nil"),
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.DeclStmt{
						Decl: &ast.GenDecl{
							Tok: token.VAR,
							Specs: []ast.Spec{
								&ast.ValueSpec{
									Names: []*ast.Ident{ast.NewIdent("zero")},
									Type:  getReturnTypeExpr(injector),
								},
							},
						},
					},
					&ast.ReturnStmt{
						Results: []ast.Expr{
							ast.NewIdent("zero"),
							ast.NewIdent("err"),
						},
					},
				},
			},
		})
	}
	
	return stmts
}

// generateChannelDeclarations creates channel declarations for cross-chain communication
func generateChannelDeclarations(plan *ParallelExecutionPlan) []ast.Stmt {
	var stmts []ast.Stmt
	
	// Collect all unique channels
	channelTypes := make(map[string]ast.Expr)
	for _, chain := range plan.Chains {
		for _, input := range chain.Inputs {
			if input.ParamType != nil {
				// Determine the type from the parameter
				providerReturnType, _ := createASTTypeExpr(getParamType(input.ParamType, plan))
				channelTypes[input.ChannelName] = &ast.ChanType{
					Dir:   ast.SEND | ast.RECV,
					Value: providerReturnType,
				}
			}
		}
	}
	
	// Generate channel declarations
	for channelName, channelType := range channelTypes {
		stmts = append(stmts, &ast.DeclStmt{
			Decl: &ast.GenDecl{
				Tok: token.VAR,
				Specs: []ast.Spec{
					&ast.ValueSpec{
						Names: []*ast.Ident{ast.NewIdent(channelName)},
						Type:  channelType,
					},
				},
			},
		})
		
		// Initialize the channel
		stmts = append(stmts, &ast.AssignStmt{
			Tok: token.ASSIGN,
			Lhs: []ast.Expr{ast.NewIdent(channelName)},
			Rhs: []ast.Expr{
				&ast.CallExpr{
					Fun: ast.NewIdent("make"),
					Args: []ast.Expr{channelType},
				},
			},
		})
	}
	
	return stmts
}

// generateResultVariableDeclarations creates variable declarations for all result parameters
func generateResultVariableDeclarations(plan *ParallelExecutionPlan) []ast.Stmt {
	var stmts []ast.Stmt
	
	for _, chain := range plan.Chains {
		for _, stmt := range chain.Statements {
			for i, ret := range stmt.Returns {
				if i < len(stmt.Provider.Provides) {
					// Use the actual provider type for this return value
					providerReturnType, _ := createASTTypeExpr(stmt.Provider.Provides[i])
					stmts = append(stmts, &ast.DeclStmt{
						Decl: &ast.GenDecl{
							Tok: token.VAR,
							Specs: []ast.Spec{
								&ast.ValueSpec{
									Names: []*ast.Ident{ast.NewIdent(ret.Name())},
									Type:  providerReturnType,
								},
							},
						},
					})
				}
			}
		}
	}
	
	return stmts
}

// generateChainGoroutine generates a goroutine for a dependency chain
func generateChainGoroutine(chain *DependencyChain) ast.Stmt {
	var goroutineBody []ast.Stmt
	
	// Check context cancellation first
	goroutineBody = append(goroutineBody, &ast.IfStmt{
		Cond: &ast.BinaryExpr{
			X: &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   ast.NewIdent("ctx"),
					Sel: ast.NewIdent("Err"),
				},
			},
			Op: token.NEQ,
			Y:  ast.NewIdent("nil"),
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("ctx"),
								Sel: ast.NewIdent("Err"),
							},
						},
					},
				},
			},
		},
	})
	
	// Receive values from channels for input dependencies
	for _, input := range chain.Inputs {
		goroutineBody = append(goroutineBody, &ast.AssignStmt{
			Tok: token.ASSIGN,
			Lhs: []ast.Expr{ast.NewIdent(input.ParamName)},
			Rhs: []ast.Expr{
				&ast.UnaryExpr{
					Op: token.ARROW,
					X:  ast.NewIdent(input.ChannelName),
				},
			},
		})
	}
	
	// Execute statements in the chain sequentially
	for _, stmt := range chain.Statements {
		// Generate function call
		args := make([]ast.Expr, 0, len(stmt.Arguments))
		for _, arg := range stmt.Arguments {
			args = append(args, ast.NewIdent(arg.Name()))
		}
		
		rhs := &ast.CallExpr{
			Fun: &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   stmt.Provider.ASTExpr,
					Sel: ast.NewIdent("Fn"),
				},
				Args: []ast.Expr{},
			},
			Args: args,
		}
		
		// Assign results
		lhs := make([]ast.Expr, 0, len(stmt.Returns)+1)
		for _, ret := range stmt.Returns {
			lhs = append(lhs, ast.NewIdent(ret.Name()))
		}
		if stmt.Provider.IsReturnError {
			lhs = append(lhs, ast.NewIdent("err"))
		}
		
		goroutineBody = append(goroutineBody, &ast.AssignStmt{
			Tok: token.ASSIGN,
			Lhs: lhs,
			Rhs: []ast.Expr{rhs},
		})
		
		// Handle error
		if stmt.Provider.IsReturnError {
			goroutineBody = append(goroutineBody, &ast.IfStmt{
				Cond: &ast.BinaryExpr{
					X:  ast.NewIdent("err"),
					Op: token.NEQ,
					Y:  ast.NewIdent("nil"),
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.ReturnStmt{
							Results: []ast.Expr{ast.NewIdent("err")},
						},
					},
				},
			})
		}
	}
	
	// Send values to channels for output dependencies
	for _, output := range chain.Outputs {
		goroutineBody = append(goroutineBody, &ast.ExprStmt{
			X: &ast.BinaryExpr{
				X:  ast.NewIdent(output.ChannelName),
				Op: token.ARROW,
				Y:  ast.NewIdent(output.ParamName),
			},
		})
	}
	
	goroutineBody = append(goroutineBody, &ast.ReturnStmt{
		Results: []ast.Expr{ast.NewIdent("nil")},
	})
	
	return &ast.ExprStmt{
		X: &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("g"),
				Sel: ast.NewIdent("Go"),
			},
			Args: []ast.Expr{
				&ast.FuncLit{
					Type: &ast.FuncType{
						Results: &ast.FieldList{
							List: []*ast.Field{
								{Type: ast.NewIdent("error")},
							},
						},
					},
					Body: &ast.BlockStmt{
						List: goroutineBody,
					},
				},
			},
		},
	}
}

// getParamType extracts the type from an InjectorParam by finding the provider that creates it
func getParamType(param *InjectorParam, plan *ParallelExecutionPlan) types.Type {
	// Find the provider statement that creates this parameter
	for _, chain := range plan.Chains {
		for _, stmt := range chain.Statements {
			for i, ret := range stmt.Returns {
				if ret == param && i < len(stmt.Provider.Provides) {
					return stmt.Provider.Provides[i]
				}
			}
		}
	}
	// Fallback to interface{} if we can't find the type
	return types.NewNamed(types.NewTypeName(0, nil, "interface{}", nil), types.NewInterfaceType(nil, nil), nil)
}
