package kessoku

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"io"
	"log/slog"
	"slices"
	"strconv"
	"strings"

	mystrings "github.com/mazrean/kessoku/internal/pkg/strings"
)

const (
	// maxInjectorReturnValues represents the maximum number of return values for an injector function
	maxInjectorReturnValues = 2
)

func Generate(w io.Writer, filename string, metaData *MetaData, injectors []*Injector) error {
	file := &ast.File{
		Name: ast.NewIdent(metaData.Package.Name),
	}

	// Generate injector function declarations and collect imports
	var funcDecls []ast.Decl
	for _, injector := range injectors {
		funcDecl, imports, err := generateInjectorDecl(metaData, injector)
		if err != nil {
			slog.Error("Failed to generate injector declaration", "error", err)
		}

		funcDecls = append(funcDecls, funcDecl)

		for _, importPath := range imports {
			if _, exists := metaData.Imports[importPath]; exists {
				continue
			}

			metaData.Imports[importPath] = &ast.ImportSpec{
				Path: &ast.BasicLit{
					Kind:  token.STRING,
					Value: strconv.Quote(importPath),
				},
			}
		}
	}

	// Generate import declaration first
	importSpecs := make([]*ast.ImportSpec, 0, len(metaData.Imports))
	for _, importSpec := range metaData.Imports {
		importSpecs = append(importSpecs, importSpec)
	}
	slices.SortFunc(importSpecs, func(a, b *ast.ImportSpec) int {
		return strings.Compare(a.Path.Value, b.Path.Value)
	})
	importDecl := generateImportDecl(importSpecs)
	if importDecl != nil {
		file.Decls = append(file.Decls, importDecl)
	}

	// Add function declarations after imports
	file.Decls = append(file.Decls, funcDecls...)

	// Add DO NOT EDIT comment
	_, err := w.Write([]byte("// Code generated by kessoku. DO NOT EDIT.\n\n"))
	if err != nil {
		return fmt.Errorf("write DO NOT EDIT comment: %w", err)
	}

	// Format and write the generated code
	err = format.Node(w, token.NewFileSet(), file)
	if err != nil {
		return fmt.Errorf("format generated code: %w", err)
	}

	return nil
}

// isContextType checks if a type is context.Context
func isContextType(t types.Type) bool {
	if named, ok := t.(*types.Named); ok {
		if obj := named.Obj(); obj != nil && obj.Pkg() != nil {
			return obj.Pkg().Path() == "context" && obj.Name() == "Context"
		}
	}

	return false
}

// detectAsyncChains determines if the injector contains async provider chains
func detectAsyncChains(injector *Injector) bool {
	for _, stmt := range injector.Stmts {
		if stmt.HasAsync() {
			return true
		}
		// Check if the ChainStmt actually contains async providers
		if chainStmt, ok := stmt.(*InjectorChainStmt); ok {
			for _, subStmt := range chainStmt.Statements {
				if subStmt.HasAsync() {
					return true
				}
			}
		}
	}
	return false
}

// generateAsyncInitialization creates errgroup and variable declarations for async execution
func generateAsyncInitialization(pkg string, injector *Injector, varPool *VarPool) ([]ast.Stmt, []string, error) {
	var stmts []ast.Stmt
	imports := []string{"golang.org/x/sync/errgroup"}

	// Check if context is available
	hasCtx := false
	for _, arg := range injector.Args {
		hasCtx = isContextType(arg.Type)
		if hasCtx {
			break
		}
	}

	// Generate variable declarations for async access
	varSpecs, newImports, err := generateVariableSpecs(pkg, injector, varPool)
	if err != nil {
		return nil, nil, fmt.Errorf("generate variable declarations: %w", err)
	}

	imports = append(imports, newImports...)
	stmts = append(stmts, &ast.DeclStmt{
		Decl: &ast.GenDecl{
			Tok:   token.VAR,
			Specs: varSpecs,
		},
	})

	// Generate errgroup declaration
	egDecl := generateErrGroupDeclaration(hasCtx)
	stmts = append(stmts, egDecl)

	return stmts, imports, nil
}

// generateErrGroupDeclaration creates the errgroup variable declaration
func generateErrGroupDeclaration(hasCtx bool) *ast.AssignStmt {
	if hasCtx {
		return &ast.AssignStmt{
			Lhs: []ast.Expr{
				ast.NewIdent("eg"),
				ast.NewIdent("ctx"),
			},
			Tok: token.DEFINE,
			Rhs: []ast.Expr{
				&ast.CallExpr{
					Fun: &ast.SelectorExpr{
						X:   ast.NewIdent("errgroup"),
						Sel: ast.NewIdent("WithContext"),
					},
					Args: []ast.Expr{ast.NewIdent("ctx")},
				},
			},
		}
	}

	return &ast.AssignStmt{
		Lhs: []ast.Expr{ast.NewIdent("eg")},
		Tok: token.DEFINE,
		Rhs: []ast.Expr{
			&ast.UnaryExpr{
				Op: token.AND,
				X: &ast.CompositeLit{
					Type: &ast.SelectorExpr{
						X:   ast.NewIdent("errgroup"),
						Sel: ast.NewIdent("Group"),
					},
				},
			},
		},
	}
}

// generateVariableSpecs creates variable declarations for async access
func generateVariableSpecs(pkg string, injector *Injector, varPool *VarPool) ([]ast.Spec, []string, error) {
	var (
		specs   []ast.Spec
		imports []string
	)

	for _, param := range injector.Params {
		paramName := param.Name(varPool)
		if paramName == "_" {
			continue
		}

		typeExpr, newImports, err := createASTTypeExpr(pkg, param.Type())
		if err != nil {
			return nil, nil, fmt.Errorf("create AST type expression for %s: %w", paramName, err)
		}

		imports = append(imports, newImports...)

		specs = append(specs, &ast.ValueSpec{
			Names: []*ast.Ident{ast.NewIdent(paramName)},
			Type:  typeExpr,
		})

		if !param.WithChannel() {
			continue
		}

		specs = append(specs, &ast.ValueSpec{
			Names: []*ast.Ident{ast.NewIdent(param.ChannelName(varPool))},
			Values: []ast.Expr{
				&ast.CallExpr{
					Fun: ast.NewIdent("make"),
					Args: []ast.Expr{
						&ast.ChanType{
							Dir:   ast.SEND | ast.RECV,
							Value: ast.NewIdent("struct{}"),
						},
					},
				},
			},
		})
	}

	return specs, imports, nil
}

// generateAsyncWaitStatements creates errgroup wait statements
func generateAsyncWaitStatements(injector *Injector) []ast.Stmt {
	if injector.IsReturnError {
		return []ast.Stmt{
			&ast.IfStmt{
				Init: &ast.AssignStmt{
					Lhs: []ast.Expr{ast.NewIdent("err")},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("eg"),
								Sel: ast.NewIdent("Wait"),
							},
						},
					},
				},
				Cond: &ast.BinaryExpr{
					X:  ast.NewIdent("err"),
					Op: token.NEQ,
					Y:  ast.NewIdent("nil"),
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.ReturnStmt{
							Results: []ast.Expr{
								ast.NewIdent("nil"),
								ast.NewIdent("err"),
							},
						},
					},
				},
			},
		}
	}

	return []ast.Stmt{
		&ast.ExprStmt{
			X: &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   ast.NewIdent("eg"),
					Sel: ast.NewIdent("Wait"),
				},
			},
		},
	}
}

func generateImportDecl(imporSpecs []*ast.ImportSpec) *ast.GenDecl {
	specs := make([]ast.Spec, 0, len(imporSpecs))
	for _, importSpec := range imporSpecs {
		specs = append(specs, importSpec)
	}
	if len(specs) == 0 {
		return nil
	}

	return &ast.GenDecl{
		Tok:   token.IMPORT,
		Specs: specs,
	}
}

func generateInjectorDecl(metaData *MetaData, injector *Injector) (ast.Decl, []string, error) {
	varPool := NewVarPool()
	paramFields := make([]*ast.Field, 0, len(injector.Args)+1)

	// Add parameters
	for _, arg := range injector.Args {
		if arg != nil && arg.ASTTypeExpr != nil && arg.Param != nil {
			paramFields = append(paramFields, &ast.Field{
				Names: []*ast.Ident{ast.NewIdent(arg.Param.Name(varPool))},
				Type:  arg.ASTTypeExpr,
			})
		}
	}

	// Return type - will be set in Results field
	resultsFields := make([]*ast.Field, 0, maxInjectorReturnValues)
	if injector.Return != nil && injector.Return.Return != nil && injector.Return.Return.ASTTypeExpr != nil {
		resultsFields = append(resultsFields, &ast.Field{
			Type: injector.Return.Return.ASTTypeExpr,
		})
	}
	if injector.IsReturnError {
		resultsFields = append(resultsFields, &ast.Field{
			Type: &ast.Ident{Name: "error"},
		})
	}

	var params *ast.FieldList
	if len(paramFields) > 0 {
		// Validate that all param fields have non-nil Type
		validParams := make([]*ast.Field, 0, len(paramFields))
		for _, field := range paramFields {
			if field != nil && field.Type != nil {
				validParams = append(validParams, field)
			}
		}
		if len(validParams) > 0 {
			params = &ast.FieldList{
				List: validParams,
			}
		}
	}

	var results *ast.FieldList
	if len(resultsFields) > 0 {
		// Validate that all result fields have non-nil Type
		validResults := make([]*ast.Field, 0, len(resultsFields))
		for _, field := range resultsFields {
			if field != nil && field.Type != nil {
				validResults = append(validResults, field)
			}
		}
		if len(validResults) > 0 {
			results = &ast.FieldList{
				List: validResults,
			}
		}
	}

	funcType := &ast.FuncType{
		Params:  params,
		Results: results,
	}

	stmts, imports, err := generateStmts(varPool, metaData.Package.Path, injector)
	if err != nil {
		return nil, nil, fmt.Errorf("generate statements: %w", err)
	}

	funcDecl := &ast.FuncDecl{
		Name: ast.NewIdent(injector.Name),
		Type: funcType,
		Body: &ast.BlockStmt{
			List: stmts,
		},
	}

	return funcDecl, imports, nil
}

// generateStmts generates statements with parallel execution support using errgroup
func generateStmts(varPool *VarPool, pkg string, injector *Injector) ([]ast.Stmt, []string, error) {
	var stmts []ast.Stmt
	var imports []string

	hasAsyncChains := detectAsyncChains(injector)

	// Initialize async components if needed
	if hasAsyncChains {
		asyncStmts, asyncImports, err := generateAsyncInitialization(pkg, injector, varPool)
		if err != nil {
			return nil, nil, fmt.Errorf("generate async initialization: %w", err)
		}

		stmts = append(stmts, asyncStmts...)
		imports = append(imports, asyncImports...)
	}

	var returnErrStmts []ast.Stmt
	if injector.Return != nil && injector.Return.Return != nil && injector.Return.Return.ASTTypeExpr != nil {
		returnErrStmts = []ast.Stmt{
			&ast.DeclStmt{
				Decl: &ast.GenDecl{
					Tok: token.VAR,
					Specs: []ast.Spec{
						&ast.ValueSpec{
							Names: []*ast.Ident{ast.NewIdent("zero")},
							Type:  injector.Return.Return.ASTTypeExpr,
						},
					},
				},
			},
			&ast.ReturnStmt{
				Results: []ast.Expr{ast.NewIdent("zero"), ast.NewIdent("err")},
			},
		}
	} else {
		returnErrStmts = []ast.Stmt{
			&ast.ReturnStmt{
				Results: []ast.Expr{ast.NewIdent("err")},
			},
		}
	}

	// Process statements and collect completion channels
	for _, stmt := range injector.Stmts {
		newStmts, newImports := stmt.Stmt(varPool, injector, returnErrStmts)
		imports = append(imports, newImports...)
		stmts = append(stmts, newStmts...)
	}

	// Add async completion handling
	if hasAsyncChains {
		waitStmts := generateAsyncWaitStatements(injector)
		stmts = append(stmts, waitStmts...)
	}

	// Add return statement
	returnExprs := make([]ast.Expr, 0, maxInjectorReturnValues)
	if injector.Return != nil && injector.Return.Param != nil {
		returnExprs = append(returnExprs, ast.NewIdent(injector.Return.Param.Name(varPool)))
	}
	if injector.IsReturnError {
		returnExprs = append(returnExprs, ast.NewIdent("nil"))
	}
	if len(returnExprs) > 0 {
		stmts = append(stmts, &ast.ReturnStmt{
			Results: returnExprs,
		})
	}

	return stmts, imports, nil
}

func (stmt *InjectorProviderCallStmt) Stmt(varPool *VarPool, injector *Injector, returnErrStmts []ast.Stmt) ([]ast.Stmt, []string) {
	var stmts []ast.Stmt

	hasAsyncChains := detectAsyncChains(injector)

	lhs := stmt.buildLhsExpressions(varPool)
	args := stmt.buildArguments(varPool)

	// Add channel synchronization for async scenarios
	if hasAsyncChains {
		waitStmt := stmt.generateChannelWaitStatement(varPool, injector)
		if waitStmt != nil {
			stmts = append(stmts, waitStmt)
		}
	}

	// Generate provider function call
	rhs := stmt.buildProviderCall(args)

	// Generate assignment statement
	assignStmt := stmt.buildAssignmentStatement(lhs, rhs, hasAsyncChains)
	stmts = append(stmts, assignStmt)

	// Add error handling if needed
	if stmt.Provider.IsReturnError {
		errorStmt := stmt.buildErrorHandlingStatement(returnErrStmts)
		stmts = append(stmts, errorStmt)
	}

	// Add channel cleanup for async scenarios
	if hasAsyncChains {
		closeStmt := stmt.generateChannelCloseStatement(varPool)
		if closeStmt != nil {
			stmts = append(stmts, closeStmt)
		}
	}

	return stmts, nil
}

func (stmt *InjectorProviderCallStmt) channelsWait(channels []ast.Expr, injector *Injector) ast.Stmt {
	// Check if context is available
	hasCtx := false
	for _, arg := range injector.Args {
		if isContextType(arg.Type) {
			hasCtx = true
			break
		}
	}

	if len(channels) == 1 {
		// Single channel case
		return stmt.buildWaitStatement(hasCtx, channels[0])
	}

	return &ast.RangeStmt{
		Tok:   token.DEFINE,
		Key:   ast.NewIdent("_"),
		Value: ast.NewIdent("ch"),
		X: &ast.CompositeLit{
			Type: &ast.ArrayType{
				Elt: &ast.ChanType{
					Dir:   ast.RECV,
					Value: ast.NewIdent("struct{}"),
				},
			},
			Elts: channels,
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				stmt.buildWaitStatement(hasCtx, ast.NewIdent("ch")),
			},
		},
	}
}

func (stmt *InjectorProviderCallStmt) buildWaitStatement(hasCtx bool, channel ast.Expr) ast.Stmt {
	if !hasCtx {
		return &ast.ExprStmt{
			X: &ast.UnaryExpr{
				Op: token.ARROW,
				X:  channel,
			},
		}
	}

	return &ast.SelectStmt{
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.CaseClause{
					List: []ast.Expr{
						&ast.UnaryExpr{
							Op: token.ARROW,
							X:  channel,
						},
					},
					Body: []ast.Stmt{},
				},
				&ast.CaseClause{
					List: []ast.Expr{
						&ast.UnaryExpr{
							Op: token.ARROW,
							X: &ast.SelectorExpr{
								X:   ast.NewIdent("ctx"),
								Sel: ast.NewIdent("Done"),
							},
						},
					},
					Body: []ast.Stmt{
						&ast.ReturnStmt{
							Results: []ast.Expr{
								&ast.CallExpr{
									Fun: &ast.SelectorExpr{
										X:   ast.NewIdent("ctx"),
										Sel: ast.NewIdent("Err"),
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func (stmt *InjectorProviderCallStmt) channelsClose(channels []ast.Expr) ast.Stmt {
	if len(channels) == 1 {
		return &ast.ExprStmt{
			X: &ast.CallExpr{
				Fun: ast.NewIdent("close"),
				Args: []ast.Expr{
					channels[0],
				},
			},
		}
	}

	/*
		ast of:
		for _, ch := range []<-chan struct{}{v1, v2, v3} {
			close(ch)
		}
	*/
	return &ast.RangeStmt{
		Tok:   token.DEFINE,
		Key:   ast.NewIdent("_"),
		Value: ast.NewIdent("ch"),
		X: &ast.CompositeLit{
			Type: &ast.ArrayType{
				Elt: &ast.ChanType{
					Dir:   ast.SEND,
					Value: ast.NewIdent("struct{}"),
				},
			},
			Elts: channels,
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: ast.NewIdent("close"),
						Args: []ast.Expr{
							ast.NewIdent("ch"),
						},
					},
				},
			},
		},
	}
}

var chainReturnErrStmts = []ast.Stmt{
	&ast.ReturnStmt{
		Results: []ast.Expr{ast.NewIdent("err")},
	},
}

func (stmt *InjectorChainStmt) Stmt(varPool *VarPool, injector *Injector, _ []ast.Stmt) ([]ast.Stmt, []string) {
	var imports []string

	// Check if this chain contains any async providers
	hasAsyncInChain := false
	for _, chainStmt := range stmt.Statements {
		if chainStmt.HasAsync() {
			hasAsyncInChain = true
			break
		}
	}

	if !hasAsyncInChain {
		// For sync-only chains, generate statements directly without goroutines
		var allStmts []ast.Stmt

		// Create proper error return statements for sync chains
		var syncReturnErrStmts []ast.Stmt
		if injector.Return != nil && injector.Return.Return != nil && injector.Return.Return.ASTTypeExpr != nil {
			syncReturnErrStmts = []ast.Stmt{
				&ast.DeclStmt{
					Decl: &ast.GenDecl{
						Tok: token.VAR,
						Specs: []ast.Spec{
							&ast.ValueSpec{
								Names: []*ast.Ident{ast.NewIdent("zero")},
								Type:  injector.Return.Return.ASTTypeExpr,
							},
						},
					},
				},
				&ast.ReturnStmt{
					Results: []ast.Expr{ast.NewIdent("zero"), ast.NewIdent("err")},
				},
			}
		} else {
			syncReturnErrStmts = []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{ast.NewIdent("err")},
				},
			}
		}

		for _, chainStmt := range stmt.Statements {
			chainStmts, chainImports := chainStmt.Stmt(varPool, injector, syncReturnErrStmts)
			allStmts = append(allStmts, chainStmts...)
			imports = append(imports, chainImports...)
		}
		return allStmts, imports
	}

	// For async chains, generate goroutine with proper variable assignment
	var stmts []ast.Stmt

	// Generate statements for this chain
	for _, chainStmt := range stmt.Statements {
		chainStmts, chainImports := chainStmt.Stmt(varPool, injector, chainReturnErrStmts)
		stmts = append(stmts, chainStmts...)
		imports = append(imports, chainImports...)
	}

	stmts = append(stmts, &ast.ReturnStmt{
		Results: []ast.Expr{ast.NewIdent("nil")},
	})

	return []ast.Stmt{
		&ast.ExprStmt{
			X: &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   ast.NewIdent("eg"),
					Sel: ast.NewIdent("Go"),
				},
				Args: []ast.Expr{
					&ast.FuncLit{
						Type: &ast.FuncType{
							Params: nil, // Empty parameter list
							Results: &ast.FieldList{
								List: []*ast.Field{
									{
										Type: &ast.Ident{Name: "error"},
									},
								},
							},
						},
						Body: &ast.BlockStmt{
							List: stmts,
						},
					},
				},
			},
		},
	}, imports
}

type VarPool struct {
	vars map[string]int
}

func NewVarPool() *VarPool {
	return &VarPool{
		vars: make(map[string]int),
	}
}

func (p *VarPool) Get(t types.Type) string {
	name := p.getBaseName(t)

	count, ok := p.vars[name]
	if !ok {
		count = 0
	}
	p.vars[name] = count + 1

	if count == 0 {
		return name
	}

	return fmt.Sprintf("%s%d", name, count-1)
}

func (p *VarPool) GetChannel(t types.Type) string {
	name := p.getBaseName(t) + "Ch"

	count, ok := p.vars[name]
	if !ok {
		count = 0
	}
	p.vars[name] = count + 1

	if count == 0 {
		return name
	}

	return fmt.Sprintf("%s%d", name, count-1)
}

// goReservedKeywords contains Go reserved keywords that cannot be used as variable names
var goReservedKeywords = map[string]bool{
	"break": true, "default": true, "func": true, "interface": true, "select": true,
	"case": true, "defer": true, "go": true, "map": true, "struct": true,
	"chan": true, "else": true, "goto": true, "package": true, "switch": true,
	"const": true, "fallthrough": true, "if": true, "range": true, "type": true,
	"continue": true, "for": true, "import": true, "return": true, "var": true,
}

// getTypeBaseName extracts a base name from a type for argument naming
func (p *VarPool) getBaseName(t types.Type) string {
	// For pointers, recurse on the element type
	for ptr, ok := t.(*types.Pointer); ok; ptr, ok = t.(*types.Pointer) {
		t = ptr.Elem()
	}

	var baseName string
	switch t := t.(type) {
	case *types.Named:
		if obj := t.Obj(); obj != nil && obj.Pkg() != nil {
			if obj.Pkg().Path() == "context" && obj.Name() == "Context" {
				return "ctx"
			}
		}

		baseName = mystrings.ToLowerCamel(t.Obj().Name())
	case *types.Basic:
		// Check by kind for all basic types (byte and rune are handled by their underlying types)
		switch t.Kind() {
		case types.Int, types.Int8, types.Int16, types.Int32, types.Int64,
			types.Uint, types.Uint8, types.Uint16, types.Uint32, types.Uint64,
			types.Float32, types.Float64,
			types.UntypedInt, types.UntypedFloat, types.UntypedRune:
			return "num"
		case types.String, types.UntypedString:
			return "str"
		case types.Bool, types.UntypedBool:
			return "flag"
		case types.Complex64, types.Complex128, types.UntypedComplex:
			return "complex"
		case types.Uintptr, types.UnsafePointer:
			return "ptr"
		case types.UntypedNil:
			return "null"
		case types.Invalid:
			return "invalid"
		default:
			baseName = mystrings.ToLowerCamel(t.Name())
		}
	default:
		baseName = "val"
	}

	// Check if the base name is a Go reserved keyword
	if goReservedKeywords[baseName] {
		return baseName + "Value"
	}

	return baseName
}

// buildLhsExpressions builds the left-hand side expressions for assignment
func (stmt *InjectorProviderCallStmt) buildLhsExpressions(varPool *VarPool) []ast.Expr {
	var lhs []ast.Expr

	// Add output parameters
	for _, param := range stmt.Returns {
		paramName := param.Name(varPool)
		lhs = append(lhs, ast.NewIdent(paramName))
	}

	// Add error parameter if provider returns error
	if stmt.Provider.IsReturnError {
		lhs = append(lhs, ast.NewIdent("err"))
	}

	return lhs
}

// buildArguments builds the arguments for the provider call
func (stmt *InjectorProviderCallStmt) buildArguments(varPool *VarPool) []ast.Expr {
	var args []ast.Expr

	// Add input parameters
	for _, arg := range stmt.Arguments {
		args = append(args, ast.NewIdent(arg.Param.Name(varPool)))
	}

	return args
}

// buildProviderCall builds the provider function call expression
func (stmt *InjectorProviderCallStmt) buildProviderCall(args []ast.Expr) []ast.Expr {
	return []ast.Expr{
		&ast.CallExpr{
			Fun: &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   stmt.Provider.ASTExpr,
					Sel: ast.NewIdent("Fn"),
				},
			},
			Args: args,
		},
	}
}

// buildAssignmentStatement builds the assignment statement
func (stmt *InjectorProviderCallStmt) buildAssignmentStatement(lhs, rhs []ast.Expr, hasAsyncChains bool) ast.Stmt {
	tokenType := token.DEFINE
	if hasAsyncChains {
		tokenType = token.ASSIGN
	}

	return &ast.AssignStmt{
		Lhs: lhs,
		Tok: tokenType,
		Rhs: rhs,
	}
}

// buildErrorHandlingStatement builds error handling statements
func (stmt *InjectorProviderCallStmt) buildErrorHandlingStatement(returnErrStmts []ast.Stmt) ast.Stmt {
	return &ast.IfStmt{
		Cond: &ast.BinaryExpr{
			X:  ast.NewIdent("err"),
			Op: token.NEQ,
			Y:  ast.NewIdent("nil"),
		},
		Body: &ast.BlockStmt{
			List: returnErrStmts,
		},
	}
}

// generateChannelWaitStatement generates channel wait statements for async coordination
func (stmt *InjectorProviderCallStmt) generateChannelWaitStatement(varPool *VarPool, injector *Injector) ast.Stmt {
	var channels []ast.Expr

	// Collect channels from dependencies
	for _, arg := range stmt.Arguments {
		if arg.IsWait {
			channels = append(channels, ast.NewIdent(arg.Param.ChannelName(varPool)))
		}
	}

	if len(channels) == 0 {
		return nil
	}

	return stmt.channelsWait(channels, injector)
}

// generateChannelCloseStatement generates channel close statements for async coordination
func (stmt *InjectorProviderCallStmt) generateChannelCloseStatement(varPool *VarPool) ast.Stmt {
	var channels []ast.Expr

	// Collect channels from output parameters
	for _, param := range stmt.Returns {
		if param.WithChannel() {
			channels = append(channels, ast.NewIdent(param.ChannelName(varPool)))
		}
	}

	if len(channels) == 0 {
		return nil
	}

	return stmt.channelsClose(channels)
}
