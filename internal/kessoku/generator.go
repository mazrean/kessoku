package kessoku

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"io"
	"log/slog"
	"slices"
	"strings"
)

const (
	// maxInjectorReturnValues represents the maximum number of return values for an injector function
	maxInjectorReturnValues = 2
)

func Generate(w io.Writer, filename string, metaData *MetaData, injectors []*Injector, varPool *VarPool) error {
	file := &ast.File{
		Name: ast.NewIdent(metaData.Package.Name),
	}

	// Generate injector function declarations
	var funcDecls []ast.Decl
	for _, injector := range injectors {
		funcDecl, err := generateInjectorDecl(metaData, injector, varPool)
		if err != nil {
			slog.Error("Failed to generate injector declaration", "error", err)
			continue
		}

		funcDecls = append(funcDecls, funcDecl)
	}

	// Generate import declarations only for used imports
	usedImports := GetUsedImports(metaData.Imports)
	importSpecs := make([]*ast.ImportSpec, 0, len(usedImports))
	for path, imp := range usedImports {
		importSpecs = append(importSpecs, importSpec(imp, path))
	}
	slices.SortFunc(importSpecs, func(a, b *ast.ImportSpec) int {
		return strings.Compare(a.Path.Value, b.Path.Value)
	})
	importDecl := generateImportDecl(importSpecs)
	if importDecl != nil {
		file.Decls = append(file.Decls, importDecl)
	}

	// Add function declarations after imports
	file.Decls = append(file.Decls, funcDecls...)

	// Add DO NOT EDIT comment
	_, err := w.Write([]byte("// Code generated by kessoku. DO NOT EDIT.\n\n"))
	if err != nil {
		return fmt.Errorf("write DO NOT EDIT comment: %w", err)
	}

	// Format and write the generated code
	err = format.Node(w, token.NewFileSet(), file)
	if err != nil {
		return fmt.Errorf("format generated code: %w", err)
	}

	return nil
}

// isContextType checks if a type is context.Context
func isContextType(t types.Type) bool {
	if named, ok := t.(*types.Named); ok {
		if obj := named.Obj(); obj != nil && obj.Pkg() != nil {
			return obj.Pkg().Path() == contextPkgPath && obj.Name() == contextTypeName
		}
	}

	return false
}

// detectAsyncChains determines if the injector contains async provider chains
func detectAsyncChains(injector *Injector) bool {
	for _, stmt := range injector.Stmts {
		// Check if the ChainStmt actually contains async providers
		if _, ok := stmt.(*InjectorChainStmt); ok {
			return true
		}
	}
	return false
}

// generateAsyncInitialization creates errgroup and variable declarations for async execution
func generateAsyncInitialization(pkg string, injector *Injector, varPool *VarPool, imports map[string]*Import) ([]ast.Stmt, error) {
	var stmts []ast.Stmt

	// Add errgroup import and mark it as used
	if imp, exists := imports[errgroupPkgPath]; exists {
		imp.IsUsed = true
	} else {
		name := varPool.GetName(errgroupPkgName)
		imports[errgroupPkgPath] = &Import{
			Name:          name,
			IsDefaultName: errgroupPkgName == name,
			IsUsed:        true,
		}
	}

	// Check if context is available
	hasCtx := false
	for _, arg := range injector.Args {
		hasCtx = isContextType(arg.Type)
		if hasCtx {
			break
		}
	}

	// Generate variable declarations for async access
	varSpecs, err := generateVariableSpecs(pkg, injector, varPool, imports)
	if err != nil {
		return nil, fmt.Errorf("generate variable declarations: %w", err)
	}

	stmts = append(stmts, &ast.DeclStmt{
		Decl: &ast.GenDecl{
			Tok:   token.VAR,
			Specs: varSpecs,
		},
	})

	// Generate errgroup declaration
	egDecl := generateErrGroupDeclaration(hasCtx)
	stmts = append(stmts, egDecl)

	return stmts, nil
}

// generateErrGroupDeclaration creates the errgroup variable declaration
func generateErrGroupDeclaration(hasCtx bool) *ast.AssignStmt {
	if hasCtx {
		return &ast.AssignStmt{
			Lhs: []ast.Expr{
				ast.NewIdent("eg"),
				ast.NewIdent("ctx"),
			},
			Tok: token.DEFINE,
			Rhs: []ast.Expr{
				&ast.CallExpr{
					Fun: &ast.SelectorExpr{
						X:   ast.NewIdent("errgroup"),
						Sel: ast.NewIdent("WithContext"),
					},
					Args: []ast.Expr{ast.NewIdent("ctx")},
				},
			},
		}
	}

	return &ast.AssignStmt{
		Lhs: []ast.Expr{ast.NewIdent("eg")},
		Tok: token.DEFINE,
		Rhs: []ast.Expr{
			&ast.UnaryExpr{
				Op: token.AND,
				X: &ast.CompositeLit{
					Type: &ast.SelectorExpr{
						X:   ast.NewIdent("errgroup"),
						Sel: ast.NewIdent("Group"),
					},
				},
			},
		},
	}
}

// generateVariableSpecs creates variable declarations for async access
func generateVariableSpecs(pkg string, injector *Injector, varPool *VarPool, imports map[string]*Import) ([]ast.Spec, error) {
	var specs []ast.Spec

	for _, param := range injector.Vars {
		paramName := param.Name(varPool)
		if paramName == "_" {
			continue
		}

		typeExpr, err := createASTTypeExpr(pkg, param.Type(), varPool, imports)
		if err != nil {
			return nil, fmt.Errorf("create AST type expression for %s: %w", paramName, err)
		}

		specs = append(specs, &ast.ValueSpec{
			Names: []*ast.Ident{ast.NewIdent(paramName)},
			Type:  typeExpr,
		})

		if !param.WithChannel() {
			continue
		}

		specs = append(specs, &ast.ValueSpec{
			Names: []*ast.Ident{ast.NewIdent(param.ChannelName(varPool))},
			Values: []ast.Expr{
				&ast.CallExpr{
					Fun: ast.NewIdent("make"),
					Args: []ast.Expr{
						&ast.ChanType{
							Dir:   ast.SEND | ast.RECV,
							Value: ast.NewIdent("struct{}"),
						},
					},
				},
			},
		})
	}

	return specs, nil
}

// generateAsyncWaitStatements creates errgroup wait statements
func generateAsyncWaitStatements(injector *Injector) []ast.Stmt {
	if injector.IsReturnError {
		errIdent := ast.NewIdent("err")

		return []ast.Stmt{
			&ast.IfStmt{
				Init: &ast.AssignStmt{
					Lhs: []ast.Expr{errIdent},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("eg"),
								Sel: ast.NewIdent("Wait"),
							},
						},
					},
				},
				Cond: &ast.BinaryExpr{
					X:  errIdent,
					Op: token.NEQ,
					Y:  ast.NewIdent("nil"),
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.ReturnStmt{
							Results: []ast.Expr{
								ast.NewIdent("nil"),
								errIdent,
							},
						},
					},
				},
			},
		}
	}

	return []ast.Stmt{
		&ast.AssignStmt{
			Lhs: []ast.Expr{ast.NewIdent("_")},
			Tok: token.ASSIGN,
			Rhs: []ast.Expr{
				&ast.CallExpr{
					Fun: &ast.SelectorExpr{
						X:   ast.NewIdent("eg"),
						Sel: ast.NewIdent("Wait"),
					},
				},
			},
		},
	}
}

func generateImportDecl(imporSpecs []*ast.ImportSpec) *ast.GenDecl {
	specs := make([]ast.Spec, 0, len(imporSpecs))
	for _, importSpec := range imporSpecs {
		specs = append(specs, importSpec)
	}
	if len(specs) == 0 {
		return nil
	}

	return &ast.GenDecl{
		Tok:   token.IMPORT,
		Specs: specs,
	}
}

func generateInjectorDecl(metaData *MetaData, injector *Injector, varPool *VarPool) (ast.Decl, error) {
	paramFields := make([]*ast.Field, 0, len(injector.Args)+1)

	// Add parameters
	for _, arg := range injector.Args {
		if arg != nil && arg.ASTTypeExpr != nil && arg.Param != nil {
			paramFields = append(paramFields, &ast.Field{
				Names: []*ast.Ident{ast.NewIdent(arg.Param.Name(varPool))},
				Type:  arg.ASTTypeExpr,
			})
		}
	}

	// Return type - will be set in Results field
	resultsFields := make([]*ast.Field, 0, maxInjectorReturnValues)
	if injector.Return != nil && injector.Return.Return != nil && injector.Return.Return.ASTTypeExpr != nil {
		resultsFields = append(resultsFields, &ast.Field{
			Type: injector.Return.Return.ASTTypeExpr,
		})
	}
	if injector.IsReturnError {
		resultsFields = append(resultsFields, &ast.Field{
			Type: &ast.Ident{Name: "error"},
		})
	}

	var params *ast.FieldList
	if len(paramFields) > 0 {
		// Validate that all param fields have non-nil Type
		validParams := make([]*ast.Field, 0, len(paramFields))
		for _, field := range paramFields {
			if field != nil && field.Type != nil {
				validParams = append(validParams, field)
			}
		}
		if len(validParams) > 0 {
			params = &ast.FieldList{
				List: validParams,
			}
		}
	}

	var results *ast.FieldList
	if len(resultsFields) > 0 {
		// Validate that all result fields have non-nil Type
		validResults := make([]*ast.Field, 0, len(resultsFields))
		for _, field := range resultsFields {
			if field != nil && field.Type != nil {
				validResults = append(validResults, field)
			}
		}
		if len(validResults) > 0 {
			results = &ast.FieldList{
				List: validResults,
			}
		}
	}

	funcType := &ast.FuncType{
		Params:  params,
		Results: results,
	}

	stmts, err := generateStmts(varPool, metaData.Package.Path, injector, metaData.Imports)
	if err != nil {
		return nil, fmt.Errorf("generate statements: %w", err)
	}

	funcDecl := &ast.FuncDecl{
		Name: ast.NewIdent(injector.Name),
		Type: funcType,
		Body: &ast.BlockStmt{
			List: stmts,
		},
	}

	return funcDecl, nil
}

// generateStmts generates statements with parallel execution support using errgroup
func generateStmts(varPool *VarPool, pkg string, injector *Injector, imports map[string]*Import) ([]ast.Stmt, error) {
	var stmts []ast.Stmt

	hasAsyncChains := detectAsyncChains(injector)

	// Initialize async components if needed
	if hasAsyncChains {
		asyncStmts, err := generateAsyncInitialization(pkg, injector, varPool, imports)
		if err != nil {
			return nil, fmt.Errorf("generate async initialization: %w", err)
		}

		stmts = append(stmts, asyncStmts...)
	}

	var returnErrStmts func(ast.Expr) []ast.Stmt
	switch {
	case !injector.IsReturnError:
		returnErrStmts = nil
	case injector.Return != nil && injector.Return.Return != nil && injector.Return.Return.ASTTypeExpr != nil:
		returnErrStmts = func(errExpr ast.Expr) []ast.Stmt {
			return []ast.Stmt{
				&ast.DeclStmt{
					Decl: &ast.GenDecl{
						Tok: token.VAR,
						Specs: []ast.Spec{
							&ast.ValueSpec{
								Names: []*ast.Ident{ast.NewIdent("zero")},
								Type:  injector.Return.Return.ASTTypeExpr,
							},
						},
					},
				},
				&ast.ReturnStmt{
					Results: []ast.Expr{ast.NewIdent("zero"), errExpr},
				},
			}
		}
	default:
		returnErrStmts = func(errExpr ast.Expr) []ast.Stmt {
			return []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{errExpr},
				},
			}
		}
	}

	// Process statements and collect completion channels
	for _, stmt := range injector.Stmts {
		newStmts, _ := stmt.Stmt(varPool, injector, returnErrStmts)
		stmts = append(stmts, newStmts...)
	}

	// Add async completion handling
	if hasAsyncChains {
		waitStmts := generateAsyncWaitStatements(injector)
		stmts = append(stmts, waitStmts...)
	}

	// Add return statement
	returnExprs := make([]ast.Expr, 0, maxInjectorReturnValues)
	if injector.Return != nil && injector.Return.Param != nil {
		returnExprs = append(returnExprs, ast.NewIdent(injector.Return.Param.Name(varPool)))
	}
	if injector.IsReturnError {
		returnExprs = append(returnExprs, ast.NewIdent("nil"))
	}
	if len(returnExprs) > 0 {
		stmts = append(stmts, &ast.ReturnStmt{
			Results: returnExprs,
		})
	}

	return stmts, nil
}

func (stmt *InjectorProviderCallStmt) Stmt(varPool *VarPool, injector *Injector, returnErrStmts func(ast.Expr) []ast.Stmt) ([]ast.Stmt, []string) {
	var stmts []ast.Stmt

	// Add channel synchronization for async scenarios
	hasAsyncChains := detectAsyncChains(injector)
	if hasAsyncChains {
		waitStmt := stmt.generateChannelWaitStatement(varPool, injector, returnErrStmts)
		if waitStmt != nil {
			stmts = append(stmts, waitStmt)
		}
	}

	// Generate provider function call
	args := stmt.buildArguments(varPool)
	rhs := stmt.buildProviderCall(args)

	// Generate assignment statement
	lhs := stmt.buildLhsExpressions(varPool)

	var errorHandleStmt ast.Stmt
	if stmt.Provider.IsReturnError {
		errIdentName := varPool.GetName("err")
		errIdent := ast.NewIdent(errIdentName)
		lhs = append(lhs, errIdent)

		stmts = append(stmts, &ast.DeclStmt{
			Decl: &ast.GenDecl{
				Tok: token.VAR,
				Specs: []ast.Spec{
					&ast.ValueSpec{
						Names: []*ast.Ident{errIdent},
						Type:  ast.NewIdent("error"),
					},
				},
			},
		})

		errorHandleStmt = stmt.buildErrorHandlingStatement(errIdent, returnErrStmts)
	}

	assignStmt := stmt.buildAssignmentStatement(lhs, rhs, hasAsyncChains)
	stmts = append(stmts, assignStmt)

	if errorHandleStmt != nil {
		stmts = append(stmts, errorHandleStmt)
	}

	// Add channel cleanup for async scenarios
	if hasAsyncChains {
		closeStmt := stmt.generateChannelCloseStatement(varPool)
		if closeStmt != nil {
			stmts = append(stmts, closeStmt)
		}
	}

	return stmts, nil
}

func (stmt *InjectorProviderCallStmt) channelsWait(channels []ast.Expr, injector *Injector, returnErrStmts func(ast.Expr) []ast.Stmt) ast.Stmt {
	// Check if context is available
	hasCtx := false
	for _, arg := range injector.Args {
		if isContextType(arg.Type) {
			hasCtx = true
			break
		}
	}

	if len(channels) == 1 {
		// Single channel case
		return stmt.buildWaitStatement(hasCtx, channels[0], returnErrStmts)
	}

	return &ast.RangeStmt{
		Tok:   token.DEFINE,
		Key:   ast.NewIdent("_"),
		Value: ast.NewIdent("ch"),
		X: &ast.CompositeLit{
			Type: &ast.ArrayType{
				Elt: &ast.ChanType{
					Dir:   ast.RECV,
					Value: ast.NewIdent("struct{}"),
				},
			},
			Elts: channels,
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				stmt.buildWaitStatement(hasCtx, ast.NewIdent("ch"), returnErrStmts),
			},
		},
	}
}

func (stmt *InjectorProviderCallStmt) buildWaitStatement(hasCtx bool, channel ast.Expr, returnErrStmts func(ast.Expr) []ast.Stmt) ast.Stmt {
	if !hasCtx || returnErrStmts == nil {
		return &ast.ExprStmt{
			X: &ast.UnaryExpr{
				Op: token.ARROW,
				X:  channel,
			},
		}
	}

	return &ast.SelectStmt{
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.CaseClause{
					List: []ast.Expr{
						&ast.UnaryExpr{
							Op: token.ARROW,
							X:  channel,
						},
					},
					Body: []ast.Stmt{},
				},
				&ast.CaseClause{
					List: []ast.Expr{
						&ast.UnaryExpr{
							Op: token.ARROW,
							X: &ast.CallExpr{
								Fun: &ast.SelectorExpr{
									X:   ast.NewIdent("ctx"),
									Sel: ast.NewIdent("Done"),
								},
							},
						},
					},
					Body: returnErrStmts(&ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   ast.NewIdent("ctx"),
							Sel: ast.NewIdent("Err"),
						},
					}),
				},
			},
		},
	}
}

func (stmt *InjectorProviderCallStmt) channelsClose(channels []ast.Expr) ast.Stmt {
	if len(channels) == 1 {
		return &ast.ExprStmt{
			X: &ast.CallExpr{
				Fun: ast.NewIdent("close"),
				Args: []ast.Expr{
					channels[0],
				},
			},
		}
	}

	/*
		ast of:
		for _, ch := range []<-chan struct{}{v1, v2, v3} {
			close(ch)
		}
	*/
	return &ast.RangeStmt{
		Tok:   token.DEFINE,
		Key:   ast.NewIdent("_"),
		Value: ast.NewIdent("ch"),
		X: &ast.CompositeLit{
			Type: &ast.ArrayType{
				Elt: &ast.ChanType{
					Dir:   ast.SEND,
					Value: ast.NewIdent("struct{}"),
				},
			},
			Elts: channels,
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: ast.NewIdent("close"),
						Args: []ast.Expr{
							ast.NewIdent("ch"),
						},
					},
				},
			},
		},
	}
}

func chainReturnErrStmts(errExpr ast.Expr) []ast.Stmt {
	return []ast.Stmt{
		&ast.ReturnStmt{
			Results: []ast.Expr{errExpr},
		},
	}
}

func (stmt *InjectorChainStmt) Stmt(varPool *VarPool, injector *Injector, _ func(ast.Expr) []ast.Stmt) ([]ast.Stmt, []string) {
	var imports []string
	var stmts []ast.Stmt

	// Generate statements for this chain
	for _, chainStmt := range stmt.Statements {
		chainStmts, chainImports := chainStmt.Stmt(varPool, injector, chainReturnErrStmts)
		stmts = append(stmts, chainStmts...)
		imports = append(imports, chainImports...)
	}

	stmts = append(stmts, &ast.ReturnStmt{
		Results: []ast.Expr{ast.NewIdent("nil")},
	})

	// Always wrap in eg.Go() call as expected by tests
	return []ast.Stmt{
		&ast.ExprStmt{
			X: &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   ast.NewIdent("eg"),
					Sel: ast.NewIdent("Go"),
				},
				Args: []ast.Expr{
					&ast.FuncLit{
						Type: &ast.FuncType{
							Params: nil, // Empty parameter list
							Results: &ast.FieldList{
								List: []*ast.Field{
									{
										Type: &ast.Ident{Name: "error"},
									},
								},
							},
						},
						Body: &ast.BlockStmt{
							List: stmts,
						},
					},
				},
			},
		},
	}, imports
}

// buildLhsExpressions builds the left-hand side expressions for assignment
func (stmt *InjectorProviderCallStmt) buildLhsExpressions(varPool *VarPool) []ast.Expr {
	var lhs []ast.Expr

	// Add output parameters, but avoid duplicates for multi-type providers
	seenParams := make(map[*InjectorParam]bool)
	for _, param := range stmt.Returns {
		if !seenParams[param] {
			paramName := param.Name(varPool)
			lhs = append(lhs, ast.NewIdent(paramName))
			seenParams[param] = true
		}
	}

	return lhs
}

// buildArguments builds the arguments for the provider call
func (stmt *InjectorProviderCallStmt) buildArguments(varPool *VarPool) []ast.Expr {
	var args []ast.Expr

	// Add input parameters
	for _, arg := range stmt.Arguments {
		args = append(args, ast.NewIdent(arg.Param.Name(varPool)))
	}

	return args
}

// buildProviderCall builds the provider function call expression
func (stmt *InjectorProviderCallStmt) buildProviderCall(args []ast.Expr) []ast.Expr {
	return []ast.Expr{
		&ast.CallExpr{
			Fun: &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   stmt.Provider.ASTExpr,
					Sel: ast.NewIdent("Fn"),
				},
			},
			Args: args,
		},
	}
}

// buildAssignmentStatement builds the assignment statement
func (stmt *InjectorProviderCallStmt) buildAssignmentStatement(lhs, rhs []ast.Expr, hasAsyncChains bool) ast.Stmt {
	tokenType := token.DEFINE
	if hasAsyncChains {
		tokenType = token.ASSIGN
	}

	return &ast.AssignStmt{
		Lhs: lhs,
		Tok: tokenType,
		Rhs: rhs,
	}
}

// buildErrorHandlingStatement builds error handling statements
func (stmt *InjectorProviderCallStmt) buildErrorHandlingStatement(errIdent *ast.Ident, returnErrStmts func(ast.Expr) []ast.Stmt) ast.Stmt {
	if returnErrStmts == nil {
		return &ast.EmptyStmt{}
	}

	return &ast.IfStmt{
		Cond: &ast.BinaryExpr{
			X:  errIdent,
			Op: token.NEQ,
			Y:  ast.NewIdent("nil"),
		},
		Body: &ast.BlockStmt{
			List: returnErrStmts(errIdent),
		},
	}
}

// generateChannelWaitStatement generates channel wait statements for async coordination
func (stmt *InjectorProviderCallStmt) generateChannelWaitStatement(varPool *VarPool, injector *Injector, returnErrStmts func(ast.Expr) []ast.Stmt) ast.Stmt {
	var channels []ast.Expr

	// Collect channels from dependencies
	for _, arg := range stmt.Arguments {
		if arg.IsWait && arg.Param.WithChannel() {
			channels = append(channels, ast.NewIdent(arg.Param.ChannelName(varPool)))
		}
	}

	if len(channels) == 0 {
		return nil
	}

	return stmt.channelsWait(channels, injector, returnErrStmts)
}

// generateChannelCloseStatement generates channel close statements for async coordination
func (stmt *InjectorProviderCallStmt) generateChannelCloseStatement(varPool *VarPool) ast.Stmt {
	var channels []ast.Expr

	// Collect channels from output parameters
	for _, param := range stmt.Returns {
		if param.WithChannel() {
			channels = append(channels, ast.NewIdent(param.ChannelName(varPool)))
		}
	}

	if len(channels) == 0 {
		return nil
	}

	return stmt.channelsClose(channels)
}
