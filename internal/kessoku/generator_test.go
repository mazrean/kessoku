package kessoku

import (
	"bytes"
	"go/ast"
	"go/types"
	"strings"
	"testing"
)

func createTestMetaData() *MetaData {
	return &MetaData{
		Package: "main",
		Imports: map[string]*ast.ImportSpec{
			"github.com/mazrean/kessoku": {
				Path: &ast.BasicLit{
					Kind:  0,
					Value: `"github.com/mazrean/kessoku"`,
				},
			},
		},
	}
}

func createTestAST() (serviceTypeExpr, intTypeExpr ast.Expr, configProviderExpr, serviceProviderExpr ast.Expr) {
	serviceTypeExpr = &ast.StarExpr{
		X: &ast.Ident{Name: "Service"},
	}

	intTypeExpr = &ast.Ident{Name: "int"}

	configProviderExpr = &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   &ast.Ident{Name: "kessoku"},
			Sel: &ast.Ident{Name: "Provide"},
		},
		Args: []ast.Expr{
			&ast.Ident{Name: "NewConfig"},
		},
	}

	serviceProviderExpr = &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   &ast.Ident{Name: "kessoku"},
			Sel: &ast.Ident{Name: "Provide"},
		},
		Args: []ast.Expr{
			&ast.Ident{Name: "NewService"},
		},
	}

	return
}

func TestGenerate(t *testing.T) {
	t.Parallel()

	configType, serviceType, intType := createTestTypes()
	serviceTypeExpr, intTypeExpr, configProviderExpr, serviceProviderExpr := createTestAST()

	tests := []struct {
		name                string
		metaData            *MetaData
		injectors           []*Injector
		expectedContains    []string
		expectedNotContains []string
		shouldError         bool
	}{
		{
			name:     "basic generation",
			metaData: createTestMetaData(),
			injectors: []*Injector{
				{
					Name:   "InitializeService",
					Params: []*InjectorParam{},
					Args:   nil,
					Stmts: []*InjectorStmt{
						{
							Provider: &ProviderSpec{
								Type:          ProviderTypeFunction,
								Provides:      [][]types.Type{{configType}},
								Requires:      []types.Type{},
								IsReturnError: false,
								ASTExpr:       configProviderExpr,
							},
							Arguments: []*InjectorParam{},
							Returns:   []*InjectorParam{NewInjectorParam("v0")},
						},
						{
							Provider: &ProviderSpec{
								Type:          ProviderTypeFunction,
								Provides:      [][]types.Type{{serviceType}},
								Requires:      []types.Type{configType},
								IsReturnError: false,
								ASTExpr:       serviceProviderExpr,
							},
							Arguments: []*InjectorParam{NewInjectorParam("v0")},
							Returns:   []*InjectorParam{NewInjectorParam("v1")},
						},
					},
					Return: &InjectorReturn{
						Param: NewInjectorParam("v1"),
						Return: &Return{
							Type:        serviceType,
							ASTTypeExpr: serviceTypeExpr,
						},
					},
					IsReturnError: false,
				},
			},
			expectedContains: []string{
				"// Code generated by kessoku. DO NOT EDIT.",
				"package main",
				"func InitializeService()",
				"github.com/mazrean/kessoku",
			},
			shouldError: false,
		},
		{
			name:     "with argument",
			metaData: createTestMetaData(),
			injectors: []*Injector{
				{
					Name:   "InitializeService",
					Params: []*InjectorParam{},
					Args: []*InjectorArgument{
						{
							Param: func() *InjectorParam {
								p := NewInjectorParam("arg")
								p.Ref() // Reference the parameter so it gets a name
								return p
							}(),
							Arg: &Argument{
								Name:        "value",
								Type:        intType,
								ASTTypeExpr: intTypeExpr,
							},
						},
					},
					Stmts: []*InjectorStmt{
						{
							Provider: &ProviderSpec{
								Type:          ProviderTypeFunction,
								Provides:      [][]types.Type{{serviceType}},
								Requires:      []types.Type{intType},
								IsReturnError: false,
								ASTExpr:       serviceProviderExpr,
							},
							Arguments: []*InjectorParam{func() *InjectorParam {
								p := NewInjectorParam("arg")
								p.Ref()
								return p
							}()},
							Returns: []*InjectorParam{NewInjectorParam("v0")},
						},
					},
					Return: &InjectorReturn{
						Param: NewInjectorParam("v0"),
						Return: &Return{
							Type:        serviceType,
							ASTTypeExpr: serviceTypeExpr,
						},
					},
					IsReturnError: false,
				},
			},
			expectedContains: []string{
				"func InitializeService(arg int)",
			},
			shouldError: false,
		},
		{
			name:     "with error handling",
			metaData: createTestMetaData(),
			injectors: []*Injector{
				{
					Name:   "InitializeService",
					Params: []*InjectorParam{},
					Args:   nil,
					Stmts: []*InjectorStmt{
						{
							Provider: &ProviderSpec{
								Type:          ProviderTypeFunction,
								Provides:      [][]types.Type{{serviceType}},
								Requires:      []types.Type{},
								IsReturnError: true,
								ASTExpr:       serviceProviderExpr,
							},
							Arguments: []*InjectorParam{},
							Returns:   []*InjectorParam{NewInjectorParam("v0")},
						},
					},
					Return: &InjectorReturn{
						Param: NewInjectorParam("v0"),
						Return: &Return{
							Type:        serviceType,
							ASTTypeExpr: serviceTypeExpr,
						},
					},
					IsReturnError: true,
				},
			},
			expectedContains: []string{
				"(*Service, error)",
				"if err != nil",
			},
			shouldError: false,
		},
		{
			name:     "multiple injectors",
			metaData: createTestMetaData(),
			injectors: []*Injector{
				{
					Name:   "InitializeService1",
					Params: []*InjectorParam{},
					Args:   nil,
					Stmts: []*InjectorStmt{
						{
							Provider: &ProviderSpec{
								Type:          ProviderTypeFunction,
								Provides:      [][]types.Type{{serviceType}},
								Requires:      []types.Type{},
								IsReturnError: false,
								ASTExpr:       serviceProviderExpr,
							},
							Arguments: []*InjectorParam{},
							Returns:   []*InjectorParam{NewInjectorParam("v0")},
						},
					},
					Return: &InjectorReturn{
						Param: NewInjectorParam("v0"),
						Return: &Return{
							Type:        serviceType,
							ASTTypeExpr: serviceTypeExpr,
						},
					},
					IsReturnError: false,
				},
				{
					Name:   "InitializeService2",
					Params: []*InjectorParam{},
					Args:   nil,
					Stmts: []*InjectorStmt{
						{
							Provider: &ProviderSpec{
								Type:          ProviderTypeFunction,
								Provides:      [][]types.Type{{serviceType}},
								Requires:      []types.Type{},
								IsReturnError: false,
								ASTExpr:       serviceProviderExpr,
							},
							Arguments: []*InjectorParam{},
							Returns:   []*InjectorParam{NewInjectorParam("v0")},
						},
					},
					Return: &InjectorReturn{
						Param: NewInjectorParam("v0"),
						Return: &Return{
							Type:        serviceType,
							ASTTypeExpr: serviceTypeExpr,
						},
					},
					IsReturnError: false,
				},
			},
			expectedContains: []string{
				"func InitializeService1()",
				"func InitializeService2()",
			},
			shouldError: false,
		},
		{
			name: "no imports",
			metaData: &MetaData{
				Package: "main",
				Imports: make(map[string]*ast.ImportSpec),
			},
			injectors: []*Injector{
				{
					Name:   "InitializeService",
					Params: []*InjectorParam{},
					Args:   nil,
					Stmts: []*InjectorStmt{
						{
							Provider: &ProviderSpec{
								Type:          ProviderTypeFunction,
								Provides:      [][]types.Type{{serviceType}},
								Requires:      []types.Type{},
								IsReturnError: false,
								ASTExpr:       serviceProviderExpr,
							},
							Arguments: []*InjectorParam{},
							Returns:   []*InjectorParam{NewInjectorParam("v0")},
						},
					},
					Return: &InjectorReturn{
						Param: NewInjectorParam("v0"),
						Return: &Return{
							Type:        serviceType,
							ASTTypeExpr: serviceTypeExpr,
						},
					},
					IsReturnError: false,
				},
			},
			expectedContains: []string{
				"package main",
				"func InitializeService()",
			},
			shouldError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			var buf bytes.Buffer
			err := Generate(&buf, "test.go", tt.metaData, tt.injectors)

			if tt.shouldError {
				if err == nil {
					t.Fatal("Expected Generate to fail")
				}
				return
			}

			if err != nil {
				t.Fatalf("Generate failed: %v", err)
			}

			generated := buf.String()

			// Check expected content
			for _, expected := range tt.expectedContains {
				if !strings.Contains(generated, expected) {
					t.Errorf("Expected generated code to contain %q, got:\n%s", expected, generated)
				}
			}

			// Check content that should not be present
			for _, notExpected := range tt.expectedNotContains {
				if strings.Contains(generated, notExpected) {
					t.Errorf("Expected generated code NOT to contain %q, got:\n%s", notExpected, generated)
				}
			}
		})
	}
}
