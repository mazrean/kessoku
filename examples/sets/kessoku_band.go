// Code generated by kessoku. DO NOT EDIT.

package main

import "github.com/mazrean/kessoku"

func InitializeAppBasic() (*App, error) {
	config := kessoku.Provide(NewConfig).Fn()()
	for range [] struct {
	}{config} {
		close(ch)
	}
	for range []<-chan struct {
	}{configCh} {
		select {
		case <-ch:
		case <-ctx.Done:
			return ctx.Err()
		}
	}
	database, err := kessoku.Provide(NewDatabase).Fn()(config)
	if err != nil {
		var zero *App
		return zero, err
	}
	for range [] struct {
	}{database} {
		close(ch)
	}
	for range []<-chan struct {
	}{databaseCh} {
		select {
		case <-ch:
		case <-ctx.Done:
			return ctx.Err()
		}
	}
	userService := kessoku.Provide(NewUserService).Fn()(database)
	for range [] struct {
	}{userService} {
		close(ch)
	}
	for range []<-chan struct {
	}{userServiceCh} {
		select {
		case <-ch:
		case <-ctx.Done:
			return ctx.Err()
		}
	}
	app := kessoku.Provide(NewApp).Fn()(userService)
	return app, nil
}
func InitializeAppWithInlineSet() (*App, error) {
	config := kessoku.Provide(NewConfig).Fn()()
	for range [] struct {
	}{config} {
		close(ch)
	}
	for range []<-chan struct {
	}{configCh} {
		select {
		case <-ch:
		case <-ctx.Done:
			return ctx.Err()
		}
	}
	database, err := kessoku.Provide(NewDatabase).Fn()(config)
	if err != nil {
		var zero *App
		return zero, err
	}
	for range [] struct {
	}{database} {
		close(ch)
	}
	for range []<-chan struct {
	}{databaseCh} {
		select {
		case <-ch:
		case <-ctx.Done:
			return ctx.Err()
		}
	}
	userService := kessoku.Provide(NewUserService).Fn()(database)
	for range [] struct {
	}{userService} {
		close(ch)
	}
	for range []<-chan struct {
	}{userServiceCh} {
		select {
		case <-ch:
		case <-ctx.Done:
			return ctx.Err()
		}
	}
	app := kessoku.Provide(NewApp).Fn()(userService)
	return app, nil
}
func InitializeAppWithSetVariable() (*App, error) {
	config := kessoku.Provide(NewConfig).Fn()()
	for range [] struct {
	}{config} {
		close(ch)
	}
	for range []<-chan struct {
	}{configCh} {
		select {
		case <-ch:
		case <-ctx.Done:
			return ctx.Err()
		}
	}
	database, err := kessoku.Provide(NewDatabase).Fn()(config)
	if err != nil {
		var zero *App
		return zero, err
	}
	for range [] struct {
	}{database} {
		close(ch)
	}
	for range []<-chan struct {
	}{databaseCh} {
		select {
		case <-ch:
		case <-ctx.Done:
			return ctx.Err()
		}
	}
	userService := kessoku.Provide(NewUserService).Fn()(database)
	for range [] struct {
	}{userService} {
		close(ch)
	}
	for range []<-chan struct {
	}{userServiceCh} {
		select {
		case <-ch:
		case <-ctx.Done:
			return ctx.Err()
		}
	}
	app := kessoku.Provide(NewApp).Fn()(userService)
	return app, nil
}
func InitializeAppWithNestedSets() (*App, error) {
	config := kessoku.Provide(NewConfig).Fn()()
	for range [] struct {
	}{config} {
		close(ch)
	}
	for range []<-chan struct {
	}{configCh} {
		select {
		case <-ch:
		case <-ctx.Done:
			return ctx.Err()
		}
	}
	database, err := kessoku.Provide(NewDatabase).Fn()(config)
	if err != nil {
		var zero *App
		return zero, err
	}
	for range [] struct {
	}{database} {
		close(ch)
	}
	for range []<-chan struct {
	}{databaseCh} {
		select {
		case <-ch:
		case <-ctx.Done:
			return ctx.Err()
		}
	}
	userService := kessoku.Provide(NewUserService).Fn()(database)
	for range [] struct {
	}{userService} {
		close(ch)
	}
	for range []<-chan struct {
	}{userServiceCh} {
		select {
		case <-ch:
		case <-ctx.Done:
			return ctx.Err()
		}
	}
	app := kessoku.Provide(NewApp).Fn()(userService)
	return app, nil
}
